"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxapi = require("@aws-cdk/cx-api");
const uniqueid_1 = require("../util/uniqueid");
exports.PATH_SEP = '/';
/**
 * Represents the building block of the construct graph.
 * When a construct is created, it is always added as a child
 */
class Construct {
    /**
     * Creates a new construct node.
     *
     * @param parent The parent construct
     * @param props  Properties for this construct
     */
    constructor(parent, id) {
        /**
         * List of children and their names
         */
        this._children = {};
        this.context = {};
        this._metadata = new Array();
        /**
         * If this is set to 'true'. addChild() calls for this construct and any child
         * will fail. This is used to prevent tree mutations during synthesis.
         */
        this._locked = false;
        this.id = id;
        this.parent = parent;
        // We say that parent is required, but some root constructs bypass the type checks and
        // actually pass in 'undefined'.
        if (parent != null) {
            if (id === '') {
                throw new Error('Only root constructs may have an empty name');
            }
            // Has side effect so must be very last thing in constructor
            parent.addChild(this, this.id);
        }
        else {
            // This is a root construct.
            this.id = id;
        }
        // Validate the name we ended up with
        if (this.id !== '') {
            this._validateId(this.id);
        }
        const components = this.rootPath().map(c => c.id);
        this.path = components.join(exports.PATH_SEP);
        this.uniqueId = components.length > 0 ? uniqueid_1.makeUniqueId(components) : '';
    }
    /**
     * Returns a string representation of this construct.
     */
    toString() {
        const path = this.path;
        return this.typename + (path.length > 0 ? ` [${path}]` : '');
    }
    /**
     * Returns a string with a tree representation of this construct and it's children.
     */
    toTreeString(depth = 0) {
        let out = '';
        for (let i = 0; i < depth; ++i) {
            out += '  ';
        }
        const name = this.id || '';
        out += `${this.typename}${name.length > 0 ? ' [' + name + ']' : ''}\n`;
        for (const child of this.children) {
            out += child.toTreeString(depth + 1);
        }
        return out;
    }
    /**
     * Return a descendant by path, or undefined
     *
     * @param name Relative name of a direct or indirect child
     * @returns a child by path or undefined if not found.
     */
    tryFindChild(path) {
        // tslint:disable-next-line:no-console
        if (path.startsWith(exports.PATH_SEP)) {
            throw new Error('Path must be relative');
        }
        const parts = path.split(exports.PATH_SEP);
        let curr = this;
        while (curr != null && parts.length > 0) {
            curr = curr._children[parts.shift()];
        }
        return curr;
    }
    /**
     * Return a descendant by path
     *
     * Throws an exception if the descendant is not found.
     *
     * @param name Relative name of a direct or indirect child
     * @returns Child with the given path.
     */
    findChild(path) {
        const ret = this.tryFindChild(path);
        if (!ret) {
            throw new Error(`No child with path: '${path}'`);
        }
        return ret;
    }
    /**
     * All direct children of this construct.
     */
    get children() {
        return Object.keys(this._children).map(k => this._children[k]);
    }
    /**
     * This can be used to set contextual values.
     * Context must be set before any children are added, since children may consult context info during construction.
     * If the key already exists, it will be overridden.
     * @param key The context key
     * @param value The context value
     */
    setContext(key, value) {
        if (this.children.length > 0) {
            const names = this.children.map(c => c.id);
            throw new Error('Cannot set context after children have been added: ' + names.join(','));
        }
        this.context[key] = value;
    }
    /**
     * Retrieves a value from tree context.
     *
     * Context is usually initialized at the root, but can be overridden at any point in the tree.
     *
     * @param key The context key
     * @returns The context value or undefined
     */
    getContext(key) {
        const value = this.context[key];
        if (value !== undefined) {
            return value;
        }
        return this.parent && this.parent.getContext(key);
    }
    /**
     * Retrieve a value from tree-global context
     *
     * It is an error if the context object is not available.
     */
    requireContext(key) {
        const value = this.getContext(key);
        if (value == null) {
            throw new Error(`You must supply a context value named '${key}'`);
        }
        return value;
    }
    /**
     * An array of metadata objects associated with this construct.
     * This can be used, for example, to implement support for deprecation notices, source mapping, etc.
     */
    get metadata() {
        return this._metadata;
    }
    /**
     * Adds a metadata entry to this construct.
     * Entries are arbitrary values and will also include a stack trace to allow tracing back to
     * the code location for when the entry was added. It can be used, for example, to include source
     * mapping in CloudFormation templates to improve diagnostics.
     *
     * @param type a string denoting the type of metadata
     * @param data the value of the metadata (can be a Token). If null/undefined, metadata will not be added.
     * @param from a function under which to restrict the metadata entry's stack trace (defaults to this.addMetadata)
     */
    addMetadata(type, data, from) {
        if (data == null) {
            return this;
        }
        const trace = createStackTrace(from || this.addMetadata);
        this._metadata.push({ type, data, trace });
        return this;
    }
    /**
     * Adds a { "aws:cdk:info": <message> } metadata entry to this construct.
     * The toolkit will display the info message when apps are synthesized.
     * @param message The info message.
     */
    addInfo(message) {
        return this.addMetadata(cxapi.INFO_METADATA_KEY, message);
    }
    /**
     * Adds a { warning: <message> } metadata entry to this construct.
     * The toolkit will display the warning when an app is synthesized, or fail
     * if run in --strict mode.
     * @param message The warning message.
     */
    addWarning(message) {
        return this.addMetadata(cxapi.WARNING_METADATA_KEY, message);
    }
    /**
     * Adds an { error: <message> } metadata entry to this construct.
     * The toolkit will fail synthesis when errors are reported.
     * @param message The error message.
     */
    addError(message) {
        return this.addMetadata(cxapi.ERROR_METADATA_KEY, message);
    }
    /**
     * This method can be implemented by derived constructs in order to perform
     * validation logic. It is called on all constructs before synthesis.
     *
     * @returns An array of validation error messages, or an empty array if there the construct is valid.
     */
    validate() {
        return [];
    }
    /**
     * Invokes 'validate' on all child constructs and then on this construct (depth-first).
     * @returns A list of validation errors. If the list is empty, all constructs are valid.
     */
    validateTree() {
        let errors = new Array();
        for (const child of this.children) {
            errors = errors.concat(child.validateTree());
        }
        const localErrors = this.validate();
        return errors.concat(localErrors.map(msg => new ValidationError(this, msg)));
    }
    /**
     * Return the ancestors (including self) of this Construct up until and excluding the indicated component
     *
     * @param to The construct to return the path components relative to, or
     * the entire list of ancestors (including root) if omitted.
     */
    ancestors(upTo) {
        const ret = new Array();
        let curr = this;
        while (curr && curr !== upTo) {
            ret.unshift(curr);
            curr = curr.parent;
        }
        return ret;
    }
    /**
     * Validate that the id of the construct legal.
     * Construct IDs can be any characters besides the path separator.
     */
    _validateId(id) {
        if (id.indexOf(exports.PATH_SEP) !== -1) {
            throw new Error(`Construct names cannot include '${exports.PATH_SEP}': ${id}`);
        }
    }
    /**
     * Throws if the `props` bag doesn't include the property `name`.
     * In the future we can add some type-checking here, maybe even auto-generate during compilation.
     * @param props The props bag.
     * @param name The name of the required property.
     *
     * @deprecated use ``requireProperty`` from ``@aws-cdk/runtime`` instead.
     */
    required(props, name) {
        if (!(name in props)) {
            throw new Error(`Construct of type ${this.typename} is missing required property: ${name}`);
        }
        const value = props[name];
        return value;
    }
    /**
     * @returns The type name of this node.
     */
    get typename() {
        const ctor = this.constructor;
        return ctor.name || 'Construct';
    }
    /**
     * Adds a child construct to this node.
     *
     * @param child The child construct
     * @param name The type name of the child construct.
     * @returns The resolved path part name of the child
     */
    addChild(child, childName) {
        if (this.locked) {
            // special error if root is locked
            if (!this.path) {
                throw new Error('Cannot add children during synthesis');
            }
            throw new Error(`Cannot add children to "${this.path}" during synthesis`);
        }
        if (childName in this._children) {
            throw new Error(`There is already a Construct with name '${childName}' in ${this.toString()}`);
        }
        this._children[childName] = child;
    }
    /**
     * Locks this construct from allowing more children to be added. After this
     * call, no more children can be added to this construct or to any children.
     */
    lock() {
        this._locked = true;
    }
    /**
     * Unlocks this costruct and allows mutations (adding children).
     */
    unlock() {
        this._locked = false;
    }
    /**
     * Return the path of components up to but excluding the root
     */
    rootPath() {
        const ancestors = this.ancestors();
        ancestors.shift();
        return ancestors;
    }
    /**
     * Returns true if this construct or any of it's parent constructs are
     * locked.
     */
    get locked() {
        if (this._locked) {
            return true;
        }
        if (this.parent && this.parent.locked) {
            return true;
        }
        return false;
    }
}
exports.Construct = Construct;
/**
 * Represents the root of a construct tree.
 * No parent and no name.
 */
class Root extends Construct {
    constructor() {
        // Bypass type checks
        super(undefined, '');
    }
}
exports.Root = Root;
class ValidationError {
    constructor(source, message) {
        this.source = source;
        this.message = message;
    }
}
exports.ValidationError = ValidationError;
// tslint:disable-next-line:ban-types
function createStackTrace(below) {
    const object = { stack: '' };
    const previousLimit = Error.stackTraceLimit;
    try {
        Error.stackTraceLimit = Number.MAX_SAFE_INTEGER;
        Error.captureStackTrace(object, below);
    }
    finally {
        Error.stackTraceLimit = previousLimit;
    }
    if (!object.stack) {
        return [];
    }
    return object.stack.split('\n').slice(1).map(s => s.replace(/^\s*at\s+/, ''));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uc3RydWN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29uc3RydWN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEseUNBQTBDO0FBQzFDLCtDQUFnRDtBQUNuQyxRQUFBLFFBQVEsR0FBRyxHQUFHLENBQUM7QUFFNUI7OztHQUdHO0FBQ0gsTUFBYSxTQUFTO0lBc0NwQjs7Ozs7T0FLRztJQUNILFlBQVksTUFBaUIsRUFBRSxFQUFVO1FBbkJ6Qzs7V0FFRztRQUNjLGNBQVMsR0FBa0MsRUFBRyxDQUFDO1FBQy9DLFlBQU8sR0FBMkIsRUFBRyxDQUFDO1FBQ3RDLGNBQVMsR0FBRyxJQUFJLEtBQUssRUFBaUIsQ0FBQztRQUV4RDs7O1dBR0c7UUFDSyxZQUFPLEdBQUcsS0FBSyxDQUFDO1FBU3RCLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO1FBQ2IsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFFckIsc0ZBQXNGO1FBQ3RGLGdDQUFnQztRQUNoQyxJQUFJLE1BQU0sSUFBSSxJQUFJLEVBQUU7WUFDbEIsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO2dCQUNiLE1BQU0sSUFBSSxLQUFLLENBQUMsNkNBQTZDLENBQUMsQ0FBQzthQUNoRTtZQUVELDREQUE0RDtZQUM1RCxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDaEM7YUFBTTtZQUNMLDRCQUE0QjtZQUM1QixJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQztTQUNkO1FBRUQscUNBQXFDO1FBQ3JDLElBQUksSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFDbEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDM0I7UUFFRCxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMs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QztBQXNCRCxNQUFhLGVBQWU7SUFDMUIsWUFBNEIsTUFBaUIsRUFBa0IsT0FBZTtRQUFsRCxXQUFNLEdBQU4sTUFBTSxDQUFXO1FBQWtCLFlBQU8sR0FBUCxPQUFPLENBQVE7SUFFOUUsQ0FBQztDQUNGO0FBSkQsMENBSUM7QUFFRCxxQ0FBcUM7QUFDckMsU0FBUyxnQkFBZ0IsQ0FBQyxLQUFlO0lBQ3ZDLE1BQU0sTUFBTSxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxDQUFDO0lBQzdCLE1BQU0sYUFBYSxHQUFHLEtBQUssQ0FBQyxlQUFlLENBQUM7SUFDNUMsSUFBSTtRQUNGLEtBQUssQ0FBQyxlQUFlLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixDQUFDO1FBQ2hELEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7S0FDeEM7WUFBUztRQUNSLEtBQUssQ0FBQyxlQUFlLEdBQUcsYUFBYSxDQUFDO0tBQ3ZDO0lBQ0QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUU7UUFDakIsT0FBTyxFQUFFLENBQUM7S0FDWDtJQUNELE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDaEYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjeGFwaSA9IHJlcXVpcmUoJ0Bhd3MtY2RrL2N4LWFwaScpO1xuaW1wb3J0IHsgbWFrZVVuaXF1ZUlkIH0gZnJvbSAnLi4vdXRpbC91bmlxdWVpZCc7XG5leHBvcnQgY29uc3QgUEFUSF9TRVAgPSAnLyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYnVpbGRpbmcgYmxvY2sgb2YgdGhlIGNvbnN0cnVjdCBncmFwaC5cbiAqIFdoZW4gYSBjb25zdHJ1Y3QgaXMgY3JlYXRlZCwgaXQgaXMgYWx3YXlzIGFkZGVkIGFzIGEgY2hpbGRcbiAqL1xuZXhwb3J0IGNsYXNzIENvbnN0cnVjdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgb2YgdGhpcyBub2RlIG9yIHVuZGVmaW5lZCBpZiB0aGlzIGlzIGEgcm9vdCBub2RlLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHBhcmVudD86IENvbnN0cnVjdDtcblxuICAvKipcbiAgICogVGhlIGxvY2FsIGlkIG9mIHRoZSBjb25zdHJ1Y3QuXG4gICAqIFRoaXMgaWQgaXMgdW5pcXVlIGFtb25nc3QgaXRzIHNpYmxpbmdzLlxuICAgKiBUbyBvYnRhaW4gYSB0cmVlLWdsb2JhbCB1bmlxdWUgaWQgZm9yIHRoaXMgY29uc3RydWN0LCB1c2UgYHVuaXF1ZUlkYC5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZnVsbCBwYXRoIG9mIHRoaXMgY29uc3RydWN0IGluIHRoZSB0cmVlLlxuICAgKiBDb21wb25lbnRzIGFyZSBzZXBhcmF0ZWQgYnkgJy8nLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHBhdGg6IHN0cmluZztcblxuICAvKipcbiAgICogQSB0cmVlLWdsb2JhbCB1bmlxdWUgYWxwaGFudW1lcmljIGlkZW50aWZpZXIgZm9yIHRoaXMgY29uc3RydWN0LlxuICAgKiBJbmNsdWRlcyBhbGwgY29tcG9uZW50cyBvZiB0aGUgdHJlZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSB1bmlxdWVJZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGNoaWxkcmVuIGFuZCB0aGVpciBuYW1lc1xuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBfY2hpbGRyZW46IHsgW25hbWU6IHN0cmluZ106IENvbnN0cnVjdCB9ID0geyB9O1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbnRleHQ6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7IH07XG4gIHByaXZhdGUgcmVhZG9ubHkgX21ldGFkYXRhID0gbmV3IEFycmF5PE1ldGFkYXRhRW50cnk+KCk7XG5cbiAgLyoqXG4gICAqIElmIHRoaXMgaXMgc2V0IHRvICd0cnVlJy4gYWRkQ2hpbGQoKSBjYWxscyBmb3IgdGhpcyBjb25zdHJ1Y3QgYW5kIGFueSBjaGlsZFxuICAgKiB3aWxsIGZhaWwuIFRoaXMgaXMgdXNlZCB0byBwcmV2ZW50IHRyZWUgbXV0YXRpb25zIGR1cmluZyBzeW50aGVzaXMuXG4gICAqL1xuICBwcml2YXRlIF9sb2NrZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBjb25zdHJ1Y3Qgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHBhcmVudCBUaGUgcGFyZW50IGNvbnN0cnVjdFxuICAgKiBAcGFyYW0gcHJvcHMgIFByb3BlcnRpZXMgZm9yIHRoaXMgY29uc3RydWN0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJlbnQ6IENvbnN0cnVjdCwgaWQ6IHN0cmluZykge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICAgIC8vIFdlIHNheSB0aGF0IHBhcmVudCBpcyByZXF1aXJlZCwgYnV0IHNvbWUgcm9vdCBjb25zdHJ1Y3RzIGJ5cGFzcyB0aGUgdHlwZSBjaGVja3MgYW5kXG4gICAgLy8gYWN0dWFsbHkgcGFzcyBpbiAndW5kZWZpbmVkJy5cbiAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgIGlmIChpZCA9PT0gJycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IHJvb3QgY29uc3RydWN0cyBtYXkgaGF2ZSBhbiBlbXB0eSBuYW1lJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhcyBzaWRlIGVmZmVjdCBzbyBtdXN0IGJlIHZlcnkgbGFzdCB0aGluZyBpbiBjb25zdHJ1Y3RvclxuICAgICAgcGFyZW50LmFkZENoaWxkKHRoaXMsIHRoaXMuaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGEgcm9vdCBjb25zdHJ1Y3QuXG4gICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgdGhlIG5hbWUgd2UgZW5kZWQgdXAgd2l0aFxuICAgIGlmICh0aGlzLmlkICE9PSAnJykge1xuICAgICAgdGhpcy5fdmFsaWRhdGVJZCh0aGlzLmlkKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wb25lbnRzID0gdGhpcy5yb290UGF0aCgpLm1hcChjID0+IGMuaWQpO1xuICAgIHRoaXMucGF0aCA9IGNvbXBvbmVudHMuam9pbihQQVRIX1NFUCk7XG4gICAgdGhpcy51bmlxdWVJZCA9IGNvbXBvbmVudHMubGVuZ3RoID4gMCA/IG1ha2VVbmlxdWVJZChjb21wb25lbnRzKSA6ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb25zdHJ1Y3QuXG4gICAqL1xuICBwdWJsaWMgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMucGF0aDtcbiAgICByZXR1cm4gdGhpcy50eXBlbmFtZSArIChwYXRoLmxlbmd0aCA+IDAgPyBgIFske3BhdGh9XWAgOiAnJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyB3aXRoIGEgdHJlZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbnN0cnVjdCBhbmQgaXQncyBjaGlsZHJlbi5cbiAgICovXG4gIHB1YmxpYyB0b1RyZWVTdHJpbmcoZGVwdGggPSAwKSB7XG4gICAgbGV0IG91dCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwdGg7ICsraSkge1xuICAgICAgb3V0ICs9ICcgICc7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSB0aGlzLmlkIHx8ICcnO1xuICAgIG91dCArPSBgJHt0aGlzLnR5cGVuYW1lfSR7bmFtZS5sZW5ndGggPiAwID8gJyBbJyArIG5hbWUgKyAnXScgOiAnJ31cXG5gO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgb3V0ICs9IGNoaWxkLnRvVHJlZVN0cmluZyhkZXB0aCArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGRlc2NlbmRhbnQgYnkgcGF0aCwgb3IgdW5kZWZpbmVkXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIFJlbGF0aXZlIG5hbWUgb2YgYSBkaXJlY3Qgb3IgaW5kaXJlY3QgY2hpbGRcbiAgICogQHJldHVybnMgYSBjaGlsZCBieSBwYXRoIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gICAqL1xuICBwdWJsaWMgdHJ5RmluZENoaWxkKHBhdGg6IHN0cmluZyk6IENvbnN0cnVjdCB8IHVuZGVmaW5lZCB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKFBBVEhfU0VQKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIG11c3QgYmUgcmVsYXRpdmUnKTtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KFBBVEhfU0VQKTtcblxuICAgIGxldCBjdXJyOiBDb25zdHJ1Y3R8dW5kZWZpbmVkID0gdGhpcztcbiAgICB3aGlsZSAoY3VyciAhPSBudWxsICYmIHBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGN1cnIgPSBjdXJyLl9jaGlsZHJlbltwYXJ0cy5zaGlmdCgpIV07XG4gICAgfVxuICAgIHJldHVybiBjdXJyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGRlc2NlbmRhbnQgYnkgcGF0aFxuICAgKlxuICAgKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBkZXNjZW5kYW50IGlzIG5vdCBmb3VuZC5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgUmVsYXRpdmUgbmFtZSBvZiBhIGRpcmVjdCBvciBpbmRpcmVjdCBjaGlsZFxuICAgKiBAcmV0dXJucyBDaGlsZCB3aXRoIHRoZSBnaXZlbiBwYXRoLlxuICAgKi9cbiAgcHVibGljIGZpbmRDaGlsZChwYXRoOiBzdHJpbmcpOiBDb25zdHJ1Y3Qge1xuICAgIGNvbnN0IHJldCA9IHRoaXMudHJ5RmluZENoaWxkKHBhdGgpO1xuICAgIGlmICghcmV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNoaWxkIHdpdGggcGF0aDogJyR7cGF0aH0nYCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogQWxsIGRpcmVjdCBjaGlsZHJlbiBvZiB0aGlzIGNvbnN0cnVjdC5cbiAgICovXG4gIHB1YmxpYyBnZXQgY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2NoaWxkcmVuKS5tYXAoayA9PiB0aGlzLl9jaGlsZHJlbltrXSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBzZXQgY29udGV4dHVhbCB2YWx1ZXMuXG4gICAqIENvbnRleHQgbXVzdCBiZSBzZXQgYmVmb3JlIGFueSBjaGlsZHJlbiBhcmUgYWRkZWQsIHNpbmNlIGNoaWxkcmVuIG1heSBjb25zdWx0IGNvbnRleHQgaW5mbyBkdXJpbmcgY29uc3RydWN0aW9uLlxuICAgKiBJZiB0aGUga2V5IGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIGJlIG92ZXJyaWRkZW4uXG4gICAqIEBwYXJhbSBrZXkgVGhlIGNvbnRleHQga2V5XG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgY29udGV4dCB2YWx1ZVxuICAgKi9cbiAgcHVibGljIHNldENvbnRleHQoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IHRoaXMuY2hpbGRyZW4ubWFwKGMgPT4gYy5pZCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgY29udGV4dCBhZnRlciBjaGlsZHJlbiBoYXZlIGJlZW4gYWRkZWQ6ICcgKyBuYW1lcy5qb2luKCcsJykpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRleHRba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIHZhbHVlIGZyb20gdHJlZSBjb250ZXh0LlxuICAgKlxuICAgKiBDb250ZXh0IGlzIHVzdWFsbHkgaW5pdGlhbGl6ZWQgYXQgdGhlIHJvb3QsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBhdCBhbnkgcG9pbnQgaW4gdGhlIHRyZWUuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgVGhlIGNvbnRleHQga2V5XG4gICAqIEByZXR1cm5zIFRoZSBjb250ZXh0IHZhbHVlIG9yIHVuZGVmaW5lZFxuICAgKi9cbiAgcHVibGljIGdldENvbnRleHQoa2V5OiBzdHJpbmcpOiBhbnkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jb250ZXh0W2tleV07XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHsgcmV0dXJuIHZhbHVlOyB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuZ2V0Q29udGV4dChrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGEgdmFsdWUgZnJvbSB0cmVlLWdsb2JhbCBjb250ZXh0XG4gICAqXG4gICAqIEl0IGlzIGFuIGVycm9yIGlmIHRoZSBjb250ZXh0IG9iamVjdCBpcyBub3QgYXZhaWxhYmxlLlxuICAgKi9cbiAgcHVibGljIHJlcXVpcmVDb250ZXh0KGtleTogc3RyaW5nKTogYW55IHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0Q29udGV4dChrZXkpO1xuXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3Qgc3VwcGx5IGEgY29udGV4dCB2YWx1ZSBuYW1lZCAnJHtrZXl9J2ApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBtZXRhZGF0YSBvYmplY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbnN0cnVjdC5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIGltcGxlbWVudCBzdXBwb3J0IGZvciBkZXByZWNhdGlvbiBub3RpY2VzLCBzb3VyY2UgbWFwcGluZywgZXRjLlxuICAgKi9cbiAgcHVibGljIGdldCBtZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG1ldGFkYXRhIGVudHJ5IHRvIHRoaXMgY29uc3RydWN0LlxuICAgKiBFbnRyaWVzIGFyZSBhcmJpdHJhcnkgdmFsdWVzIGFuZCB3aWxsIGFsc28gaW5jbHVkZSBhIHN0YWNrIHRyYWNlIHRvIGFsbG93IHRyYWNpbmcgYmFjayB0b1xuICAgKiB0aGUgY29kZSBsb2NhdGlvbiBmb3Igd2hlbiB0aGUgZW50cnkgd2FzIGFkZGVkLiBJdCBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIGluY2x1ZGUgc291cmNlXG4gICAqIG1hcHBpbmcgaW4gQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGVzIHRvIGltcHJvdmUgZGlhZ25vc3RpY3MuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIGEgc3RyaW5nIGRlbm90aW5nIHRoZSB0eXBlIG9mIG1ldGFkYXRhXG4gICAqIEBwYXJhbSBkYXRhIHRoZSB2YWx1ZSBvZiB0aGUgbWV0YWRhdGEgKGNhbiBiZSBhIFRva2VuKS4gSWYgbnVsbC91bmRlZmluZWQsIG1ldGFkYXRhIHdpbGwgbm90IGJlIGFkZGVkLlxuICAgKiBAcGFyYW0gZnJvbSBhIGZ1bmN0aW9uIHVuZGVyIHdoaWNoIHRvIHJlc3RyaWN0IHRoZSBtZXRhZGF0YSBlbnRyeSdzIHN0YWNrIHRyYWNlIChkZWZhdWx0cyB0byB0aGlzLmFkZE1ldGFkYXRhKVxuICAgKi9cbiAgcHVibGljIGFkZE1ldGFkYXRhKHR5cGU6IHN0cmluZywgZGF0YTogYW55LCBmcm9tPzogYW55KTogQ29uc3RydWN0IHtcbiAgICBpZiAoZGF0YSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgdHJhY2UgPSBjcmVhdGVTdGFja1RyYWNlKGZyb20gfHwgdGhpcy5hZGRNZXRhZGF0YSk7XG4gICAgdGhpcy5fbWV0YWRhdGEucHVzaCh7IHR5cGUsIGRhdGEsIHRyYWNlIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB7IFwiYXdzOmNkazppbmZvXCI6IDxtZXNzYWdlPiB9IG1ldGFkYXRhIGVudHJ5IHRvIHRoaXMgY29uc3RydWN0LlxuICAgKiBUaGUgdG9vbGtpdCB3aWxsIGRpc3BsYXkgdGhlIGluZm8gbWVzc2FnZSB3aGVuIGFwcHMgYXJlIHN5bnRoZXNpemVkLlxuICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgaW5mbyBtZXNzYWdlLlxuICAgKi9cbiAgcHVibGljIGFkZEluZm8obWVzc2FnZTogc3RyaW5nKTogQ29uc3RydWN0IHtcbiAgICByZXR1cm4gdGhpcy5hZGRNZXRhZGF0YShjeGFwaS5JTkZPX01FVEFEQVRBX0tFWSwgbWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHsgd2FybmluZzogPG1lc3NhZ2U+IH0gbWV0YWRhdGEgZW50cnkgdG8gdGhpcyBjb25zdHJ1Y3QuXG4gICAqIFRoZSB0b29sa2l0IHdpbGwgZGlzcGxheSB0aGUgd2FybmluZyB3aGVuIGFuIGFwcCBpcyBzeW50aGVzaXplZCwgb3IgZmFpbFxuICAgKiBpZiBydW4gaW4gLS1zdHJpY3QgbW9kZS5cbiAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAgICovXG4gIHB1YmxpYyBhZGRXYXJuaW5nKG1lc3NhZ2U6IHN0cmluZyk6IENvbnN0cnVjdCB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTWV0YWRhdGEoY3hhcGkuV0FSTklOR19NRVRBREFUQV9LRVksIG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4geyBlcnJvcjogPG1lc3NhZ2U+IH0gbWV0YWRhdGEgZW50cnkgdG8gdGhpcyBjb25zdHJ1Y3QuXG4gICAqIFRoZSB0b29sa2l0IHdpbGwgZmFpbCBzeW50aGVzaXMgd2hlbiBlcnJvcnMgYXJlIHJlcG9ydGVkLlxuICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAgICovXG4gIHB1YmxpYyBhZGRFcnJvcihtZXNzYWdlOiBzdHJpbmcpOiBDb25zdHJ1Y3Qge1xuICAgIHJldHVybiB0aGlzLmFkZE1ldGFkYXRhKGN4YXBpLkVSUk9SX01FVEFEQVRBX0tFWSwgbWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2FuIGJlIGltcGxlbWVudGVkIGJ5IGRlcml2ZWQgY29uc3RydWN0cyBpbiBvcmRlciB0byBwZXJmb3JtXG4gICAqIHZhbGlkYXRpb24gbG9naWMuIEl0IGlzIGNhbGxlZCBvbiBhbGwgY29uc3RydWN0cyBiZWZvcmUgc3ludGhlc2lzLlxuICAgKlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yIG1lc3NhZ2VzLCBvciBhbiBlbXB0eSBhcnJheSBpZiB0aGVyZSB0aGUgY29uc3RydWN0IGlzIHZhbGlkLlxuICAgKi9cbiAgcHVibGljIHZhbGlkYXRlKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlcyAndmFsaWRhdGUnIG9uIGFsbCBjaGlsZCBjb25zdHJ1Y3RzIGFuZCB0aGVuIG9uIHRoaXMgY29uc3RydWN0IChkZXB0aC1maXJzdCkuXG4gICAqIEByZXR1cm5zIEEgbGlzdCBvZiB2YWxpZGF0aW9uIGVycm9ycy4gSWYgdGhlIGxpc3QgaXMgZW1wdHksIGFsbCBjb25zdHJ1Y3RzIGFyZSB2YWxpZC5cbiAgICovXG4gIHB1YmxpYyB2YWxpZGF0ZVRyZWUoKTogVmFsaWRhdGlvbkVycm9yW10ge1xuICAgIGxldCBlcnJvcnMgPSBuZXcgQXJyYXk8VmFsaWRhdGlvbkVycm9yPigpO1xuXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGNoaWxkLnZhbGlkYXRlVHJlZSgpKTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2NhbEVycm9ycyA9IHRoaXMudmFsaWRhdGUoKTtcbiAgICByZXR1cm4gZXJyb3JzLmNvbmNhdChsb2NhbEVycm9ycy5tYXAobXNnID0+IG5ldyBWYWxpZGF0aW9uRXJyb3IodGhpcywgbXNnKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYW5jZXN0b3JzIChpbmNsdWRpbmcgc2VsZikgb2YgdGhpcyBDb25zdHJ1Y3QgdXAgdW50aWwgYW5kIGV4Y2x1ZGluZyB0aGUgaW5kaWNhdGVkIGNvbXBvbmVudFxuICAgKlxuICAgKiBAcGFyYW0gdG8gVGhlIGNvbnN0cnVjdCB0byByZXR1cm4gdGhlIHBhdGggY29tcG9uZW50cyByZWxhdGl2ZSB0bywgb3JcbiAgICogdGhlIGVudGlyZSBsaXN0IG9mIGFuY2VzdG9ycyAoaW5jbHVkaW5nIHJvb3QpIGlmIG9taXR0ZWQuXG4gICAqL1xuICBwdWJsaWMgYW5jZXN0b3JzKHVwVG8/OiBDb25zdHJ1Y3QpOiBDb25zdHJ1Y3RbXSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IEFycmF5PENvbnN0cnVjdD4oKTtcblxuICAgIGxldCBjdXJyOiBDb25zdHJ1Y3QgfCB1bmRlZmluZWQgPSB0aGlzO1xuICAgIHdoaWxlIChjdXJyICYmIGN1cnIgIT09IHVwVG8pIHtcbiAgICAgIHJldC51bnNoaWZ0KGN1cnIpO1xuICAgICAgY3VyciA9IGN1cnIucGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhhdCB0aGUgaWQgb2YgdGhlIGNvbnN0cnVjdCBsZWdhbC5cbiAgICogQ29uc3RydWN0IElEcyBjYW4gYmUgYW55IGNoYXJhY3RlcnMgYmVzaWRlcyB0aGUgcGF0aCBzZXBhcmF0b3IuXG4gICAqL1xuICBwcm90ZWN0ZWQgX3ZhbGlkYXRlSWQoaWQ6IHN0cmluZykge1xuICAgIGlmIChpZC5pbmRleE9mKFBBVEhfU0VQKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29uc3RydWN0IG5hbWVzIGNhbm5vdCBpbmNsdWRlICcke1BBVEhfU0VQfSc6ICR7aWR9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRocm93cyBpZiB0aGUgYHByb3BzYCBiYWcgZG9lc24ndCBpbmNsdWRlIHRoZSBwcm9wZXJ0eSBgbmFtZWAuXG4gICAqIEluIHRoZSBmdXR1cmUgd2UgY2FuIGFkZCBzb21lIHR5cGUtY2hlY2tpbmcgaGVyZSwgbWF5YmUgZXZlbiBhdXRvLWdlbmVyYXRlIGR1cmluZyBjb21waWxhdGlvbi5cbiAgICogQHBhcmFtIHByb3BzIFRoZSBwcm9wcyBiYWcuXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSByZXF1aXJlZCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBgcmVxdWlyZVByb3BlcnR5YGAgZnJvbSBgYEBhd3MtY2RrL3J1bnRpbWVgYCBpbnN0ZWFkLlxuICAgKi9cbiAgcHJvdGVjdGVkIHJlcXVpcmVkKHByb3BzOiBhbnksIG5hbWU6IHN0cmluZyk6IGFueSB7XG4gICAgaWYgKCEobmFtZSBpbiBwcm9wcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29uc3RydWN0IG9mIHR5cGUgJHt0aGlzLnR5cGVuYW1lfSBpcyBtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5OiAke25hbWV9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSBwcm9wc1tuYW1lXTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgVGhlIHR5cGUgbmFtZSBvZiB0aGlzIG5vZGUuXG4gICAqL1xuICBwcml2YXRlIGdldCB0eXBlbmFtZSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGN0b3I6IGFueSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3IubmFtZSB8fCAnQ29uc3RydWN0JztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2hpbGQgY29uc3RydWN0IHRvIHRoaXMgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGNoaWxkIFRoZSBjaGlsZCBjb25zdHJ1Y3RcbiAgICogQHBhcmFtIG5hbWUgVGhlIHR5cGUgbmFtZSBvZiB0aGUgY2hpbGQgY29uc3RydWN0LlxuICAgKiBAcmV0dXJucyBUaGUgcmVzb2x2ZWQgcGF0aCBwYXJ0IG5hbWUgb2YgdGhlIGNoaWxkXG4gICAqL1xuICBwcm90ZWN0ZWQgYWRkQ2hpbGQoY2hpbGQ6IENvbnN0cnVjdCwgY2hpbGROYW1lOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5sb2NrZWQpIHtcblxuICAgICAgLy8gc3BlY2lhbCBlcnJvciBpZiByb290IGlzIGxvY2tlZFxuICAgICAgaWYgKCF0aGlzLnBhdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWRkIGNoaWxkcmVuIGR1cmluZyBzeW50aGVzaXMnKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYWRkIGNoaWxkcmVuIHRvIFwiJHt0aGlzLnBhdGh9XCIgZHVyaW5nIHN5bnRoZXNpc2ApO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5hbWUgaW4gdGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgYWxyZWFkeSBhIENvbnN0cnVjdCB3aXRoIG5hbWUgJyR7Y2hpbGROYW1lfScgaW4gJHt0aGlzLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2hpbGRyZW5bY2hpbGROYW1lXSA9IGNoaWxkO1xuICB9XG5cbiAgLyoqXG4gICAqIExvY2tzIHRoaXMgY29uc3RydWN0IGZyb20gYWxsb3dpbmcgbW9yZSBjaGlsZHJlbiB0byBiZSBhZGRlZC4gQWZ0ZXIgdGhpc1xuICAgKiBjYWxsLCBubyBtb3JlIGNoaWxkcmVuIGNhbiBiZSBhZGRlZCB0byB0aGlzIGNvbnN0cnVjdCBvciB0byBhbnkgY2hpbGRyZW4uXG4gICAqL1xuICBwcm90ZWN0ZWQgbG9jaygpIHtcbiAgICB0aGlzLl9sb2NrZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVubG9ja3MgdGhpcyBjb3N0cnVjdCBhbmQgYWxsb3dzIG11dGF0aW9ucyAoYWRkaW5nIGNoaWxkcmVuKS5cbiAgICovXG4gIHByb3RlY3RlZCB1bmxvY2soKSB7XG4gICAgdGhpcy5fbG9ja2VkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBwYXRoIG9mIGNvbXBvbmVudHMgdXAgdG8gYnV0IGV4Y2x1ZGluZyB0aGUgcm9vdFxuICAgKi9cbiAgcHJpdmF0ZSByb290UGF0aCgpOiBDb25zdHJ1Y3RbXSB7XG4gICAgY29uc3QgYW5jZXN0b3JzID0gdGhpcy5hbmNlc3RvcnMoKTtcbiAgICBhbmNlc3RvcnMuc2hpZnQoKTtcbiAgICByZXR1cm4gYW5jZXN0b3JzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbnN0cnVjdCBvciBhbnkgb2YgaXQncyBwYXJlbnQgY29uc3RydWN0cyBhcmVcbiAgICogbG9ja2VkLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldCBsb2NrZWQoKSB7XG4gICAgaWYgKHRoaXMuX2xvY2tlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmxvY2tlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcm9vdCBvZiBhIGNvbnN0cnVjdCB0cmVlLlxuICogTm8gcGFyZW50IGFuZCBubyBuYW1lLlxuICovXG5leHBvcnQgY2xhc3MgUm9vdCBleHRlbmRzIENvbnN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIEJ5cGFzcyB0eXBlIGNoZWNrc1xuICAgIHN1cGVyKHVuZGVmaW5lZCBhcyBhbnksICcnKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIG1ldGFkYXRhIGVudHJ5IGluIHRoZSBjb25zdHJ1Y3QuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWV0YWRhdGFFbnRyeSB7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgbWV0YWRhdGEgZW50cnkuXG4gICAqL1xuICB0eXBlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBkYXRhLlxuICAgKi9cbiAgZGF0YT86IGFueTtcblxuICAvKipcbiAgICogQSBzdGFjayB0cmFjZSBmb3Igd2hlbiB0aGUgZW50cnkgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICB0cmFjZTogc3RyaW5nW107XG59XG5cbmV4cG9ydCBjbGFzcyBWYWxpZGF0aW9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgc291cmNlOiBDb25zdHJ1Y3QsIHB1YmxpYyByZWFkb25seSBtZXNzYWdlOiBzdHJpbmcpIHtcblxuICB9XG59XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpiYW4tdHlwZXNcbmZ1bmN0aW9uIGNyZWF0ZVN0YWNrVHJhY2UoYmVsb3c6IEZ1bmN0aW9uKTogc3RyaW5nW10ge1xuICBjb25zdCBvYmplY3QgPSB7IHN0YWNrOiAnJyB9O1xuICBjb25zdCBwcmV2aW91c0xpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICB0cnkge1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKG9iamVjdCwgYmVsb3cpO1xuICB9IGZpbmFsbHkge1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IHByZXZpb3VzTGltaXQ7XG4gIH1cbiAgaWYgKCFvYmplY3Quc3RhY2spIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIG9iamVjdC5zdGFjay5zcGxpdCgnXFxuJykuc2xpY2UoMSkubWFwKHMgPT4gcy5yZXBsYWNlKC9eXFxzKmF0XFxzKy8sICcnKSk7XG59XG4iXX0=