"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const construct_1 = require("./construct");
/**
 * If objects has a function property by this name, they will be considered tokens, and this
 * function will be called to resolve the value for this object.
 */
exports.RESOLVE_METHOD = 'resolve';
/**
 * Represents a special or lazily-evaluated value.
 *
 * Can be used to delay evaluation of a certain value in case, for example,
 * that it requires some context or late-bound data. Can also be used to
 * mark values that need special processing at document rendering time.
 *
 * Tokens can be embedded into strings while retaining their original
 * semantics.
 */
class Token {
    /**
     * Creates a token that resolves to `value`.
     *
     * If value is a function, the function is evaluated upon resolution and
     * the value it returns will be used as the token's value.
     *
     * displayName is used to represent the Token when it's embedded into a string; it
     * will look something like this:
     *
     *    "embedded in a larger string is ${Token[DISPLAY_NAME.123]}"
     *
     * This value is used as a hint to humans what the meaning of the Token is,
     * and does not have any effect on the evaluation.
     *
     * Must contain only alphanumeric and simple separator characters (_.:-).
     *
     * @param valueOrFunction What this token will evaluate to, literal or function.
     * @param displayName A human-readable display hint for this Token
     */
    constructor(valueOrFunction, displayName) {
        this.valueOrFunction = valueOrFunction;
        this.displayName = displayName;
    }
    /**
     * @returns The resolved value for this token.
     */
    resolve() {
        let value = this.valueOrFunction;
        if (typeof (value) === 'function') {
            value = value();
        }
        return value;
    }
    /**
     * Return a reversible string representation of this token
     *
     * If the Token is initialized with a literal, the stringified value of the
     * literal is returned. Otherwise, a special quoted string representation
     * of the Token is returned that can be embedded into other strings.
     *
     * Strings with quoted Tokens in them can be restored back into
     * complex values with the Tokens restored by calling `resolve()`
     * on the string.
     */
    toString() {
        const valueType = typeof this.valueOrFunction;
        // Optimization: if we can immediately resolve this, don't bother
        // registering a Token.
        if (valueType === 'string' || valueType === 'number' || valueType === 'boolean') {
            return this.valueOrFunction.toString();
        }
        if (this.tokenKey === undefined) {
            this.tokenKey = TOKEN_STRING_MAP.register(this, this.displayName);
        }
        return this.tokenKey;
    }
    /**
     * Turn this Token into JSON
     *
     * This gets called by JSON.stringify(). We want to prohibit this, because
     * it's not possible to do this properly, so we just throw an error here.
     */
    toJSON() {
        // tslint:disable-next-line:max-line-length
        throw new Error('JSON.stringify() cannot be applied to structure with a Token in it. Use a document-specific stringification method instead.');
    }
    /**
     * Return a concated version of this Token in a string context
     *
     * The default implementation of this combines strings, but specialized
     * implements of Token can return a more appropriate value.
     */
    concat(left, right) {
        const parts = [left, resolve(this), right].filter(x => x !== undefined);
        return new Token(parts.map(x => `${x}`).join(''));
    }
}
exports.Token = Token;
/**
 * Returns true if obj is a token (i.e. has the resolve() method or is a string
 * that includes token markers).
 * @param obj The object to test.
 */
function unresolved(obj) {
    if (typeof (obj) === 'string') {
        return TOKEN_STRING_MAP.createTokenString(obj).test();
    }
    else {
        return typeof (obj[exports.RESOLVE_METHOD]) === 'function';
    }
}
exports.unresolved = unresolved;
/**
 * Resolves an object by evaluating all tokens and removing any undefined or empty objects or arrays.
 * Values can only be primitives, arrays or tokens. Other objects (i.e. with methods) will be rejected.
 *
 * @param obj The object to resolve.
 * @param prefix Prefix key path components for diagnostics.
 */
function resolve(obj, prefix) {
    const path = prefix || [];
    const pathName = '/' + path.join('/');
    // protect against cyclic references by limiting depth.
    if (path.length > 200) {
        throw new Error('Unable to resolve object tree with circular reference. Path: ' + pathName);
    }
    //
    // undefined
    //
    if (typeof (obj) === 'undefined') {
        return undefined;
    }
    //
    // null
    //
    if (obj === null) {
        return null;
    }
    //
    // functions - not supported (only tokens are supported)
    //
    if (typeof (obj) === 'function') {
        throw new Error(`Trying to resolve a non-data object. Only token are supported for lazy evaluation. Path: ${pathName}. Object: ${obj}`);
    }
    //
    // string - potentially replace all stringified Tokens
    //
    if (typeof (obj) === 'string') {
        return TOKEN_STRING_MAP.resolveMarkers(obj);
    }
    //
    // primitives - as-is
    //
    if (typeof (obj) !== 'object' || obj instanceof Date) {
        return obj;
    }
    //
    // tokens - invoke 'resolve' and continue to resolve recursively
    //
    if (unresolved(obj)) {
        const value = obj[exports.RESOLVE_METHOD]();
        return resolve(value, path);
    }
    //
    // arrays - resolve all values, remove undefined and remove empty arrays
    //
    if (Array.isArray(obj)) {
        const arr = obj
            .map((x, i) => resolve(x, path.concat(i.toString())))
            .filter(x => typeof (x) !== 'undefined');
        return arr;
    }
    //
    // objects - deep-resolve all values
    //
    // Must not be a Construct at this point, otherwise you probably made a type
    // mistake somewhere and resolve will get into an infinite loop recursing into
    // child.parent <---> parent.children
    if (obj instanceof construct_1.Construct) {
        throw new Error('Trying to resolve() a Construct at ' + pathName);
    }
    const result = {};
    for (const key of Object.keys(obj)) {
        const resolvedKey = resolve(key);
        if (typeof (resolvedKey) !== 'string') {
            throw new Error(`The key "${key}" has been resolved to ${JSON.stringify(resolvedKey)} but must be resolvable to a string`);
        }
        const value = resolve(obj[key], path.concat(key));
        // skip undefined
        if (typeof (value) === 'undefined') {
            continue;
        }
        result[resolvedKey] = value;
    }
    return result;
}
exports.resolve = resolve;
/**
 * Central place where we keep a mapping from Tokens to their String representation
 *
 * The string representation is used to embed token into strings,
 * and stored to be able to
 *
 * All instances of TokenStringMap share the same storage, so that this process
 * works even when different copies of the library are loaded.
 */
class TokenStringMap {
    constructor() {
        const glob = global;
        this.tokenMap = glob.__cdkTokenMap = glob.__cdkTokenMap || {};
    }
    /**
     * Generating a unique string for this Token, returning a key
     *
     * Every call for the same Token will produce a new unique string, no
     * attempt is made to deduplicate. Token objects should cache the
     * value themselves, if required.
     *
     * The token can choose (part of) its own representation string with a
     * hint. This may be used to produce aesthetically pleasing and
     * recognizable token representations for humans.
     */
    register(token, representationHint) {
        const counter = Object.keys(this.tokenMap).length;
        const representation = representationHint || `TOKEN`;
        const key = `${representation}.${counter}`;
        if (new RegExp(`[^${VALID_KEY_CHARS}]`).exec(key)) {
            throw new Error(`Invalid characters in token representation: ${key}`);
        }
        this.tokenMap[key] = token;
        return `${BEGIN_TOKEN_MARKER}${key}${END_TOKEN_MARKER}`;
    }
    /**
     * Returns a `TokenString` for this string.
     */
    createTokenString(s) {
        return new TokenString(s, BEGIN_TOKEN_MARKER, `[${VALID_KEY_CHARS}]+`, END_TOKEN_MARKER);
    }
    /**
     * Replace any Token markers in this string with their resolved values
     */
    resolveMarkers(s) {
        const str = this.createTokenString(s);
        const fragments = str.split(this.lookupToken.bind(this));
        return fragments.join();
    }
    /**
     * Find a Token by key
     */
    lookupToken(key) {
        if (!(key in this.tokenMap)) {
            throw new Error(`Unrecognized token key: ${key}`);
        }
        return this.tokenMap[key];
    }
}
const BEGIN_TOKEN_MARKER = '${Token[';
const END_TOKEN_MARKER = ']}';
const VALID_KEY_CHARS = 'a-zA-Z0-9:._-';
/**
 * Singleton instance of the token string map
 */
const TOKEN_STRING_MAP = new TokenStringMap();
/**
 * A string with markers in it that can be resolved to external values
 */
class TokenString {
    constructor(str, beginMarker, idPattern, endMarker) {
        this.str = str;
        this.beginMarker = beginMarker;
        this.idPattern = idPattern;
        this.endMarker = endMarker;
        this.pattern = `${regexQuote(this.beginMarker)}(${this.idPattern})${regexQuote(this.endMarker)}`;
    }
    /**
     * Split string on markers, substituting markers with Tokens
     */
    split(lookup) {
        const re = new RegExp(this.pattern, 'g');
        const ret = new TokenStringFragments();
        let rest = 0;
        let m = re.exec(this.str);
        while (m) {
            if (m.index > rest) {
                ret.addString(this.str.substring(rest, m.index));
            }
            ret.addToken(lookup(m[1]));
            rest = re.lastIndex;
            m = re.exec(this.str);
        }
        if (rest < this.str.length) {
            ret.addString(this.str.substring(rest));
        }
        return ret;
    }
    /**
     * Indicates if this string includes tokens.
     */
    test() {
        const re = new RegExp(this.pattern, 'g');
        return re.test(this.str);
    }
}
/**
 * Fragments of a string with markers
 */
class TokenStringFragments {
    constructor() {
        this.fragments = new Array();
    }
    values() {
        return this.fragments.map(f => f.type === 'token' ? resolve(f.token) : f.str);
    }
    addString(str) {
        this.fragments.push({ type: 'string', str });
    }
    addToken(token) {
        this.fragments.push({ type: 'token', token });
    }
    /**
     * Combine the resolved string fragments using the Tokens to join.
     *
     * Resolves the result.
     */
    join() {
        if (this.fragments.length === 0) {
            return '';
        }
        if (this.fragments.length === 1) {
            return resolveFragment(this.fragments[0]);
        }
        const first = this.fragments[0];
        let i;
        let token;
        if (first.type === 'token') {
            token = first.token;
            i = 1;
        }
        else {
            // We never have two strings in a row
            token = this.fragments[1].token.concat(first.str, undefined);
            i = 2;
        }
        while (i < this.fragments.length) {
            token = token.concat(undefined, resolveFragment(this.fragments[i]));
            i++;
        }
        return resolve(token);
    }
}
/**
 * Resolve the value from a single fragment
 */
function resolveFragment(fragment) {
    return fragment.type === 'string' ? fragment.str : resolve(fragment.token);
}
/**
 * Quote a string for use in a regex
 */
function regexQuote(s) {
    return s.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW5zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidG9rZW5zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsMkNBQXdDO0FBRXhDOzs7R0FHRztBQUNVLFFBQUEsY0FBYyxHQUFHLFNBQVMsQ0FBQztBQUV4Qzs7Ozs7Ozs7O0dBU0c7QUFDSCxNQUFhLEtBQUs7SUFHaEI7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWtCRztJQUNILFlBQTZCLGVBQXFCLEVBQW1CLFdBQW9CO1FBQTVELG9CQUFlLEdBQWYsZUFBZSxDQUFNO1FBQW1CLGdCQUFXLEdBQVgsV0FBVyxDQUFTO0lBQ3pGLENBQUM7SUFFRDs7T0FFRztJQUNJLE9BQU87UUFDWixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDO1FBQ2pDLElBQUksT0FBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLFVBQVUsRUFBRTtZQUNoQyxLQUFLLEdBQUcsS0FBSyxFQUFFLENBQUM7U0FDakI7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0ksUUFBUTtRQUNiLE1BQU0sU0FBUyxHQUFHLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQztRQUM5QyxpRUFBaUU7UUFDakUsdUJBQXVCO1FBQ3ZCLElBQUksU0FBUyxLQUFLLFFBQVEsSUFBSSxTQUFTLEtBQUssUUFBUSxJQUFJLFNBQVMsS0FBSyxTQUFTLEVBQUU7WUFDL0UsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQ3hDO1FBRUQsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLFNBQVMsRUFBRTtZQUMvQixJQUFJLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1NBQ25FO1FBQ0QsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLE1BQU07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QUFTLENBQUMsQ0FBQztZQUNoRixDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ1A7UUFFRCxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRTtZQUNoQyxLQUFLLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsZUFBZSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3BFLENBQUMsRUFBRSxDQUFDO1NBQ0w7UUFFRCxPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QixDQUFDO0NBQ0Y7QUFFRDs7R0FFRztBQUNILFNBQVMsZUFBZSxDQUFDLFFBQWtCO0lBQ3pDLE9BQU8sUUFBUSxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDN0UsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxVQUFVLENBQUMsQ0FBUztJQUMzQixPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsc0JBQXNCLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDbkQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gXCIuL2NvbnN0cnVjdFwiO1xuXG4vKipcbiAqIElmIG9iamVjdHMgaGFzIGEgZnVuY3Rpb24gcHJvcGVydHkgYnkgdGhpcyBuYW1lLCB0aGV5IHdpbGwgYmUgY29uc2lkZXJlZCB0b2tlbnMsIGFuZCB0aGlzXG4gKiBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byByZXNvbHZlIHRoZSB2YWx1ZSBmb3IgdGhpcyBvYmplY3QuXG4gKi9cbmV4cG9ydCBjb25zdCBSRVNPTFZFX01FVEhPRCA9ICdyZXNvbHZlJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3BlY2lhbCBvciBsYXppbHktZXZhbHVhdGVkIHZhbHVlLlxuICpcbiAqIENhbiBiZSB1c2VkIHRvIGRlbGF5IGV2YWx1YXRpb24gb2YgYSBjZXJ0YWluIHZhbHVlIGluIGNhc2UsIGZvciBleGFtcGxlLFxuICogdGhhdCBpdCByZXF1aXJlcyBzb21lIGNvbnRleHQgb3IgbGF0ZS1ib3VuZCBkYXRhLiBDYW4gYWxzbyBiZSB1c2VkIHRvXG4gKiBtYXJrIHZhbHVlcyB0aGF0IG5lZWQgc3BlY2lhbCBwcm9jZXNzaW5nIGF0IGRvY3VtZW50IHJlbmRlcmluZyB0aW1lLlxuICpcbiAqIFRva2VucyBjYW4gYmUgZW1iZWRkZWQgaW50byBzdHJpbmdzIHdoaWxlIHJldGFpbmluZyB0aGVpciBvcmlnaW5hbFxuICogc2VtYW50aWNzLlxuICovXG5leHBvcnQgY2xhc3MgVG9rZW4ge1xuICBwcml2YXRlIHRva2VuS2V5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdG9rZW4gdGhhdCByZXNvbHZlcyB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gaXMgZXZhbHVhdGVkIHVwb24gcmVzb2x1dGlvbiBhbmRcbiAgICogdGhlIHZhbHVlIGl0IHJldHVybnMgd2lsbCBiZSB1c2VkIGFzIHRoZSB0b2tlbidzIHZhbHVlLlxuICAgKlxuICAgKiBkaXNwbGF5TmFtZSBpcyB1c2VkIHRvIHJlcHJlc2VudCB0aGUgVG9rZW4gd2hlbiBpdCdzIGVtYmVkZGVkIGludG8gYSBzdHJpbmc7IGl0XG4gICAqIHdpbGwgbG9vayBzb21ldGhpbmcgbGlrZSB0aGlzOlxuICAgKlxuICAgKiAgICBcImVtYmVkZGVkIGluIGEgbGFyZ2VyIHN0cmluZyBpcyAke1Rva2VuW0RJU1BMQVlfTkFNRS4xMjNdfVwiXG4gICAqXG4gICAqIFRoaXMgdmFsdWUgaXMgdXNlZCBhcyBhIGhpbnQgdG8gaHVtYW5zIHdoYXQgdGhlIG1lYW5pbmcgb2YgdGhlIFRva2VuIGlzLFxuICAgKiBhbmQgZG9lcyBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBldmFsdWF0aW9uLlxuICAgKlxuICAgKiBNdXN0IGNvbnRhaW4gb25seSBhbHBoYW51bWVyaWMgYW5kIHNpbXBsZSBzZXBhcmF0b3IgY2hhcmFjdGVycyAoXy46LSkuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZU9yRnVuY3Rpb24gV2hhdCB0aGlzIHRva2VuIHdpbGwgZXZhbHVhdGUgdG8sIGxpdGVyYWwgb3IgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBkaXNwbGF5TmFtZSBBIGh1bWFuLXJlYWRhYmxlIGRpc3BsYXkgaGludCBmb3IgdGhpcyBUb2tlblxuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSB2YWx1ZU9yRnVuY3Rpb24/OiBhbnksIHByaXZhdGUgcmVhZG9ubHkgZGlzcGxheU5hbWU/OiBzdHJpbmcpIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBUaGUgcmVzb2x2ZWQgdmFsdWUgZm9yIHRoaXMgdG9rZW4uXG4gICAqL1xuICBwdWJsaWMgcmVzb2x2ZSgpOiBhbnkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMudmFsdWVPckZ1bmN0aW9uO1xuICAgIGlmICh0eXBlb2YodmFsdWUpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHJldmVyc2libGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdG9rZW5cbiAgICpcbiAgICogSWYgdGhlIFRva2VuIGlzIGluaXRpYWxpemVkIHdpdGggYSBsaXRlcmFsLCB0aGUgc3RyaW5naWZpZWQgdmFsdWUgb2YgdGhlXG4gICAqIGxpdGVyYWwgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSwgYSBzcGVjaWFsIHF1b3RlZCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICogb2YgdGhlIFRva2VuIGlzIHJldHVybmVkIHRoYXQgY2FuIGJlIGVtYmVkZGVkIGludG8gb3RoZXIgc3RyaW5ncy5cbiAgICpcbiAgICogU3RyaW5ncyB3aXRoIHF1b3RlZCBUb2tlbnMgaW4gdGhlbSBjYW4gYmUgcmVzdG9yZWQgYmFjayBpbnRvXG4gICAqIGNvbXBsZXggdmFsdWVzIHdpdGggdGhlIFRva2VucyByZXN0b3JlZCBieSBjYWxsaW5nIGByZXNvbHZlKClgXG4gICAqIG9uIHRoZSBzdHJpbmcuXG4gICAqL1xuICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB0eXBlb2YgdGhpcy52YWx1ZU9yRnVuY3Rpb247XG4gICAgLy8gT3B0aW1pemF0aW9uOiBpZiB3ZSBjYW4gaW1tZWRpYXRlbHkgcmVzb2x2ZSB0aGlzLCBkb24ndCBib3RoZXJcbiAgICAvLyByZWdpc3RlcmluZyBhIFRva2VuLlxuICAgIGlmICh2YWx1ZVR5cGUgPT09ICdzdHJpbmcnIHx8IHZhbHVlVHlwZSA9PT0gJ251bWJlcicgfHwgdmFsdWVUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlT3JGdW5jdGlvbi50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRva2VuS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudG9rZW5LZXkgPSBUT0tFTl9TVFJJTkdfTUFQLnJlZ2lzdGVyKHRoaXMsIHRoaXMuZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50b2tlbktleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUdXJuIHRoaXMgVG9rZW4gaW50byBKU09OXG4gICAqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgYnkgSlNPTi5zdHJpbmdpZnkoKS4gV2Ugd2FudCB0byBwcm9oaWJpdCB0aGlzLCBiZWNhdXNlXG4gICAqIGl0J3Mgbm90IHBvc3NpYmxlIHRvIGRvIHRoaXMgcHJvcGVybHksIHNvIHdlIGp1c3QgdGhyb3cgYW4gZXJyb3IgaGVyZS5cbiAgICovXG4gIHB1YmxpYyB0b0pTT04oKTogYW55IHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgdGhyb3cgbmV3IEVycm9yKCdKU09OLnN0cmluZ2lmeSgpIGNhbm5vdCBiZSBhcHBsaWVkIHRvIHN0cnVjdHVyZSB3aXRoIGEgVG9rZW4gaW4gaXQuIFVzZSBhIGRvY3VtZW50LXNwZWNpZmljIHN0cmluZ2lmaWNhdGlvbiBtZXRob2QgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBjb25jYXRlZCB2ZXJzaW9uIG9mIHRoaXMgVG9rZW4gaW4gYSBzdHJpbmcgY29udGV4dFxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGNvbWJpbmVzIHN0cmluZ3MsIGJ1dCBzcGVjaWFsaXplZFxuICAgKiBpbXBsZW1lbnRzIG9mIFRva2VuIGNhbiByZXR1cm4gYSBtb3JlIGFwcHJvcHJpYXRlIHZhbHVlLlxuICAgKi9cbiAgcHVibGljIGNvbmNhdChsZWZ0OiBhbnkgfCB1bmRlZmluZWQsIHJpZ2h0OiBhbnkgfCB1bmRlZmluZWQpOiBUb2tlbiB7XG4gICAgY29uc3QgcGFydHMgPSBbbGVmdCwgcmVzb2x2ZSh0aGlzKSwgcmlnaHRdLmZpbHRlcih4ID0+IHggIT09IHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihwYXJ0cy5tYXAoeCA9PiBgJHt4fWApLmpvaW4oJycpKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSB0b2tlbiAoaS5lLiBoYXMgdGhlIHJlc29sdmUoKSBtZXRob2Qgb3IgaXMgYSBzdHJpbmdcbiAqIHRoYXQgaW5jbHVkZXMgdG9rZW4gbWFya2VycykuXG4gKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVucmVzb2x2ZWQob2JqOiBhbnkpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZihvYmopID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBUT0tFTl9TVFJJTkdfTUFQLmNyZWF0ZVRva2VuU3RyaW5nKG9iaikudGVzdCgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0eXBlb2Yob2JqW1JFU09MVkVfTUVUSE9EXSkgPT09ICdmdW5jdGlvbic7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNvbHZlcyBhbiBvYmplY3QgYnkgZXZhbHVhdGluZyBhbGwgdG9rZW5zIGFuZCByZW1vdmluZyBhbnkgdW5kZWZpbmVkIG9yIGVtcHR5IG9iamVjdHMgb3IgYXJyYXlzLlxuICogVmFsdWVzIGNhbiBvbmx5IGJlIHByaW1pdGl2ZXMsIGFycmF5cyBvciB0b2tlbnMuIE90aGVyIG9iamVjdHMgKGkuZS4gd2l0aCBtZXRob2RzKSB3aWxsIGJlIHJlamVjdGVkLlxuICpcbiAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCB0byByZXNvbHZlLlxuICogQHBhcmFtIHByZWZpeCBQcmVmaXgga2V5IHBhdGggY29tcG9uZW50cyBmb3IgZGlhZ25vc3RpY3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlKG9iajogYW55LCBwcmVmaXg/OiBzdHJpbmdbXSk6IGFueSB7XG4gIGNvbnN0IHBhdGggPSBwcmVmaXggfHwgWyBdO1xuICBjb25zdCBwYXRoTmFtZSA9ICcvJyArIHBhdGguam9pbignLycpO1xuXG4gIC8vIHByb3RlY3QgYWdhaW5zdCBjeWNsaWMgcmVmZXJlbmNlcyBieSBsaW1pdGluZyBkZXB0aC5cbiAgaWYgKHBhdGgubGVuZ3RoID4gMjAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcmVzb2x2ZSBvYmplY3QgdHJlZSB3aXRoIGNpcmN1bGFyIHJlZmVyZW5jZS4gUGF0aDogJyArIHBhdGhOYW1lKTtcbiAgfVxuXG4gIC8vXG4gIC8vIHVuZGVmaW5lZFxuICAvL1xuXG4gIGlmICh0eXBlb2Yob2JqKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy9cbiAgLy8gbnVsbFxuICAvL1xuXG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vXG4gIC8vIGZ1bmN0aW9ucyAtIG5vdCBzdXBwb3J0ZWQgKG9ubHkgdG9rZW5zIGFyZSBzdXBwb3J0ZWQpXG4gIC8vXG5cbiAgaWYgKHR5cGVvZihvYmopID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUcnlpbmcgdG8gcmVzb2x2ZSBhIG5vbi1kYXRhIG9iamVjdC4gT25seSB0b2tlbiBhcmUgc3VwcG9ydGVkIGZvciBsYXp5IGV2YWx1YXRpb24uIFBhdGg6ICR7cGF0aE5hbWV9LiBPYmplY3Q6ICR7b2JqfWApO1xuICB9XG5cbiAgLy9cbiAgLy8gc3RyaW5nIC0gcG90ZW50aWFsbHkgcmVwbGFjZSBhbGwgc3RyaW5naWZpZWQgVG9rZW5zXG4gIC8vXG4gIGlmICh0eXBlb2Yob2JqKSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gVE9LRU5fU1RSSU5HX01BUC5yZXNvbHZlTWFya2VycyhvYmogYXMgc3RyaW5nKTtcbiAgfVxuXG4gIC8vXG4gIC8vIHByaW1pdGl2ZXMgLSBhcy1pc1xuICAvL1xuXG4gIGlmICh0eXBlb2Yob2JqKSAhPT0gJ29iamVjdCcgfHwgb2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvL1xuICAvLyB0b2tlbnMgLSBpbnZva2UgJ3Jlc29sdmUnIGFuZCBjb250aW51ZSB0byByZXNvbHZlIHJlY3Vyc2l2ZWx5XG4gIC8vXG5cbiAgaWYgKHVucmVzb2x2ZWQob2JqKSkge1xuICAgIGNvbnN0IHZhbHVlID0gb2JqW1JFU09MVkVfTUVUSE9EXSgpO1xuICAgIHJldHVybiByZXNvbHZlKHZhbHVlLCBwYXRoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIGFycmF5cyAtIHJlc29sdmUgYWxsIHZhbHVlcywgcmVtb3ZlIHVuZGVmaW5lZCBhbmQgcmVtb3ZlIGVtcHR5IGFycmF5c1xuICAvL1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBjb25zdCBhcnIgPSBvYmpcbiAgICAgIC5tYXAoKHgsIGkpID0+IHJlc29sdmUoeCwgcGF0aC5jb25jYXQoaS50b1N0cmluZygpKSkpXG4gICAgICAuZmlsdGVyKHggPT4gdHlwZW9mKHgpICE9PSAndW5kZWZpbmVkJyk7XG5cbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgLy9cbiAgLy8gb2JqZWN0cyAtIGRlZXAtcmVzb2x2ZSBhbGwgdmFsdWVzXG4gIC8vXG5cbiAgLy8gTXVzdCBub3QgYmUgYSBDb25zdHJ1Y3QgYXQgdGhpcyBwb2ludCwgb3RoZXJ3aXNlIHlvdSBwcm9iYWJseSBtYWRlIGEgdHlwZVxuICAvLyBtaXN0YWtlIHNvbWV3aGVyZSBhbmQgcmVzb2x2ZSB3aWxsIGdldCBpbnRvIGFuIGluZmluaXRlIGxvb3AgcmVjdXJzaW5nIGludG9cbiAgLy8gY2hpbGQucGFyZW50IDwtLS0+IHBhcmVudC5jaGlsZHJlblxuICBpZiAob2JqIGluc3RhbmNlb2YgQ29uc3RydWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gcmVzb2x2ZSgpIGEgQ29uc3RydWN0IGF0ICcgKyBwYXRoTmFtZSk7XG4gIH1cblxuICBjb25zdCByZXN1bHQ6IGFueSA9IHsgfTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgIGNvbnN0IHJlc29sdmVkS2V5ID0gcmVzb2x2ZShrZXkpO1xuICAgIGlmICh0eXBlb2YocmVzb2x2ZWRLZXkpICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUga2V5IFwiJHtrZXl9XCIgaGFzIGJlZW4gcmVzb2x2ZWQgdG8gJHtKU09OLnN0cmluZ2lmeShyZXNvbHZlZEtleSl9IGJ1dCBtdXN0IGJlIHJlc29sdmFibGUgdG8gYSBzdHJpbmdgKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IHJlc29sdmUob2JqW2tleV0sIHBhdGguY29uY2F0KGtleSkpO1xuXG4gICAgLy8gc2tpcCB1bmRlZmluZWRcbiAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc3VsdFtyZXNvbHZlZEtleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2VudHJhbCBwbGFjZSB3aGVyZSB3ZSBrZWVwIGEgbWFwcGluZyBmcm9tIFRva2VucyB0byB0aGVpciBTdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGlzIHVzZWQgdG8gZW1iZWQgdG9rZW4gaW50byBzdHJpbmdzLFxuICogYW5kIHN0b3JlZCB0byBiZSBhYmxlIHRvXG4gKlxuICogQWxsIGluc3RhbmNlcyBvZiBUb2tlblN0cmluZ01hcCBzaGFyZSB0aGUgc2FtZSBzdG9yYWdlLCBzbyB0aGF0IHRoaXMgcHJvY2Vzc1xuICogd29ya3MgZXZlbiB3aGVuIGRpZmZlcmVudCBjb3BpZXMgb2YgdGhlIGxpYnJhcnkgYXJlIGxvYWRlZC5cbiAqL1xuY2xhc3MgVG9rZW5TdHJpbmdNYXAge1xuICBwcml2YXRlIHJlYWRvbmx5IHRva2VuTWFwOiB7W2tleTogc3RyaW5nXTogVG9rZW59O1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IGdsb2IgPSBnbG9iYWwgYXMgYW55O1xuICAgIHRoaXMudG9rZW5NYXAgPSBnbG9iLl9fY2RrVG9rZW5NYXAgPSBnbG9iLl9fY2RrVG9rZW5NYXAgfHwge307XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGluZyBhIHVuaXF1ZSBzdHJpbmcgZm9yIHRoaXMgVG9rZW4sIHJldHVybmluZyBhIGtleVxuICAgKlxuICAgKiBFdmVyeSBjYWxsIGZvciB0aGUgc2FtZSBUb2tlbiB3aWxsIHByb2R1Y2UgYSBuZXcgdW5pcXVlIHN0cmluZywgbm9cbiAgICogYXR0ZW1wdCBpcyBtYWRlIHRvIGRlZHVwbGljYXRlLiBUb2tlbiBvYmplY3RzIHNob3VsZCBjYWNoZSB0aGVcbiAgICogdmFsdWUgdGhlbXNlbHZlcywgaWYgcmVxdWlyZWQuXG4gICAqXG4gICAqIFRoZSB0b2tlbiBjYW4gY2hvb3NlIChwYXJ0IG9mKSBpdHMgb3duIHJlcHJlc2VudGF0aW9uIHN0cmluZyB3aXRoIGFcbiAgICogaGludC4gVGhpcyBtYXkgYmUgdXNlZCB0byBwcm9kdWNlIGFlc3RoZXRpY2FsbHkgcGxlYXNpbmcgYW5kXG4gICAqIHJlY29nbml6YWJsZSB0b2tlbiByZXByZXNlbnRhdGlvbnMgZm9yIGh1bWFucy5cbiAgICovXG4gIHB1YmxpYyByZWdpc3Rlcih0b2tlbjogVG9rZW4sIHJlcHJlc2VudGF0aW9uSGludD86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgY291bnRlciA9IE9iamVjdC5rZXlzKHRoaXMudG9rZW5NYXApLmxlbmd0aDtcbiAgICBjb25zdCByZXByZXNlbnRhdGlvbiA9IHJlcHJlc2VudGF0aW9uSGludCB8fCBgVE9LRU5gO1xuXG4gICAgY29uc3Qga2V5ID0gYCR7cmVwcmVzZW50YXRpb259LiR7Y291bnRlcn1gO1xuICAgIGlmIChuZXcgUmVnRXhwKGBbXiR7VkFMSURfS0VZX0NIQVJTfV1gKS5leGVjKGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGFyYWN0ZXJzIGluIHRva2VuIHJlcHJlc2VudGF0aW9uOiAke2tleX1gKTtcbiAgICB9XG5cbiAgICB0aGlzLnRva2VuTWFwW2tleV0gPSB0b2tlbjtcbiAgICByZXR1cm4gYCR7QkVHSU5fVE9LRU5fTUFSS0VSfSR7a2V5fSR7RU5EX1RPS0VOX01BUktFUn1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBgVG9rZW5TdHJpbmdgIGZvciB0aGlzIHN0cmluZy5cbiAgICovXG4gIHB1YmxpYyBjcmVhdGVUb2tlblN0cmluZyhzOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHMsIEJFR0lOX1RPS0VOX01BUktFUiwgYFske1ZBTElEX0tFWV9DSEFSU31dK2AsIEVORF9UT0tFTl9NQVJLRVIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgYW55IFRva2VuIG1hcmtlcnMgaW4gdGhpcyBzdHJpbmcgd2l0aCB0aGVpciByZXNvbHZlZCB2YWx1ZXNcbiAgICovXG4gIHB1YmxpYyByZXNvbHZlTWFya2VycyhzOiBzdHJpbmcpOiBhbnkge1xuICAgIGNvbnN0IHN0ciA9IHRoaXMuY3JlYXRlVG9rZW5TdHJpbmcocyk7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gc3RyLnNwbGl0KHRoaXMubG9va3VwVG9rZW4uYmluZCh0aGlzKSk7XG4gICAgcmV0dXJuIGZyYWdtZW50cy5qb2luKCk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhIFRva2VuIGJ5IGtleVxuICAgKi9cbiAgcHVibGljIGxvb2t1cFRva2VuKGtleTogc3RyaW5nKTogVG9rZW4ge1xuICAgIGlmICghKGtleSBpbiB0aGlzLnRva2VuTWFwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgdG9rZW4ga2V5OiAke2tleX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50b2tlbk1hcFtrZXldO1xuICB9XG59XG5cbmNvbnN0IEJFR0lOX1RPS0VOX01BUktFUiA9ICcke1Rva2VuWyc7XG5jb25zdCBFTkRfVE9LRU5fTUFSS0VSID0gJ119JztcbmNvbnN0IFZBTElEX0tFWV9DSEFSUyA9ICdhLXpBLVowLTk6Ll8tJztcblxuLyoqXG4gKiBTaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIHRva2VuIHN0cmluZyBtYXBcbiAqL1xuY29uc3QgVE9LRU5fU1RSSU5HX01BUCA9IG5ldyBUb2tlblN0cmluZ01hcCgpO1xuXG4vKipcbiAqIEludGVyZmFjZSB0aGF0IFRva2VuIGpvaW5lcnMgaW1wbGVtZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVRva2VuSm9pbmVyIHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBqb2luZXIuXG4gICAqXG4gICAqIE11c3QgYmUgdW5pcXVlIHBlciBqb2luZXI6IHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkIHRvIGFzc2VydCB0aGF0IHRoZXJlXG4gICAqIGlzIGV4YWN0bHkgb25seSB0eXBlIG9mIGpvaW5lciBpbiBhIGpvaW4gb3BlcmF0aW9uLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsYW5ndWFnZSBpbnRyaW5zaWMgdGhhdCB3aWxsIGNvbWJpbmUgdGhlIHN0cmluZ3MgaW4gdGhlIGdpdmVuIGVuZ2luZVxuICAgKi9cbiAgam9pbihmcmFnbWVudHM6IGFueVtdKTogYW55O1xufVxuXG4vKipcbiAqIEEgc3RyaW5nIHdpdGggbWFya2VycyBpbiBpdCB0aGF0IGNhbiBiZSByZXNvbHZlZCB0byBleHRlcm5hbCB2YWx1ZXNcbiAqL1xuY2xhc3MgVG9rZW5TdHJpbmcge1xuICBwcml2YXRlIHBhdHRlcm46IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0cjogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYmVnaW5NYXJrZXI6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGlkUGF0dGVybjogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZW5kTWFya2VyOiBzdHJpbmcpIHtcbiAgICB0aGlzLnBhdHRlcm4gPSBgJHtyZWdleFF1b3RlKHRoaXMuYmVnaW5NYXJrZXIpfSgke3RoaXMuaWRQYXR0ZXJufSkke3JlZ2V4UXVvdGUodGhpcy5lbmRNYXJrZXIpfWA7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgc3RyaW5nIG9uIG1hcmtlcnMsIHN1YnN0aXR1dGluZyBtYXJrZXJzIHdpdGggVG9rZW5zXG4gICAqL1xuICBwdWJsaWMgc3BsaXQobG9va3VwOiAoaWQ6IHN0cmluZykgPT4gVG9rZW4pOiBUb2tlblN0cmluZ0ZyYWdtZW50cyB7XG4gICAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKHRoaXMucGF0dGVybiwgJ2cnKTtcbiAgICBjb25zdCByZXQgPSBuZXcgVG9rZW5TdHJpbmdGcmFnbWVudHMoKTtcblxuICAgIGxldCByZXN0ID0gMDtcbiAgICBsZXQgbSA9IHJlLmV4ZWModGhpcy5zdHIpO1xuICAgIHdoaWxlIChtKSB7XG4gICAgICBpZiAobS5pbmRleCA+IHJlc3QpIHtcbiAgICAgICAgcmV0LmFkZFN0cmluZyh0aGlzLnN0ci5zdWJzdHJpbmcocmVzdCwgbS5pbmRleCkpO1xuICAgICAgfVxuXG4gICAgICByZXQuYWRkVG9rZW4obG9va3VwKG1bMV0pKTtcblxuICAgICAgcmVzdCA9IHJlLmxhc3RJbmRleDtcbiAgICAgIG0gPSByZS5leGVjKHRoaXMuc3RyKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdCA8IHRoaXMuc3RyLmxlbmd0aCkge1xuICAgICAgcmV0LmFkZFN0cmluZyh0aGlzLnN0ci5zdWJzdHJpbmcocmVzdCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHRoaXMgc3RyaW5nIGluY2x1ZGVzIHRva2Vucy5cbiAgICovXG4gIHB1YmxpYyB0ZXN0KCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cCh0aGlzLnBhdHRlcm4sICdnJyk7XG4gICAgcmV0dXJuIHJlLnRlc3QodGhpcy5zdHIpO1xuICB9XG59XG5cbi8qKlxuICogUmVzdWx0IG9mIHRoZSBzcGxpdCBvZiBhIHN0cmluZyB3aXRoIFRva2Vuc1xuICpcbiAqIEVpdGhlciBhIGxpdGVyYWwgcGFydCBvZiB0aGUgc3RyaW5nLCBvciBhbiB1bnJlc29sdmVkIFRva2VuLlxuICovXG50eXBlIFN0cmluZ0ZyYWdtZW50ID0geyB0eXBlOiAnc3RyaW5nJzsgc3RyOiBzdHJpbmcgfTtcbnR5cGUgVG9rZW5GcmFnbWVudCA9IHsgdHlwZTogJ3Rva2VuJzsgdG9rZW46IFRva2VuIH07XG50eXBlIEZyYWdtZW50ID0gIFN0cmluZ0ZyYWdtZW50IHwgVG9rZW5GcmFnbWVudDtcblxuLyoqXG4gKiBGcmFnbWVudHMgb2YgYSBzdHJpbmcgd2l0aCBtYXJrZXJzXG4gKi9cbmNsYXNzIFRva2VuU3RyaW5nRnJhZ21lbnRzIHtcbiAgcHJpdmF0ZSByZWFkb25seSBmcmFnbWVudHMgPSBuZXcgQXJyYXk8RnJhZ21lbnQ+KCk7XG5cbiAgcHVibGljIHZhbHVlcygpOiBhbnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRzLm1hcChmID0+IGYudHlwZSA9PT0gJ3Rva2VuJyA/IHJlc29sdmUoZi50b2tlbikgOiBmLnN0cik7XG4gIH1cblxuICBwdWJsaWMgYWRkU3RyaW5nKHN0cjogc3RyaW5nKSB7XG4gICAgdGhpcy5mcmFnbWVudHMucHVzaCh7IHR5cGU6ICdzdHJpbmcnLCBzdHIgfSk7XG4gIH1cblxuICBwdWJsaWMgYWRkVG9rZW4odG9rZW46IFRva2VuKSB7XG4gICAgdGhpcy5mcmFnbWVudHMucHVzaCh7IHR5cGU6ICd0b2tlbicsIHRva2VuIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbWJpbmUgdGhlIHJlc29sdmVkIHN0cmluZyBmcmFnbWVudHMgdXNpbmcgdGhlIFRva2VucyB0byBqb2luLlxuICAgKlxuICAgKiBSZXNvbHZlcyB0aGUgcmVzdWx0LlxuICAgKi9cbiAgcHVibGljIGpvaW4oKTogYW55IHtcbiAgICBpZiAodGhpcy5mcmFnbWVudHMubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJzsgfVxuICAgIGlmICh0aGlzLmZyYWdtZW50cy5sZW5ndGggPT09IDEpIHsgcmV0dXJuIHJlc29sdmVGcmFnbWVudCh0aGlzLmZyYWdtZW50c1swXSk7IH1cblxuICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5mcmFnbWVudHNbMF07XG5cbiAgICBsZXQgaTtcbiAgICBsZXQgdG9rZW46IFRva2VuO1xuXG4gICAgaWYgKGZpcnN0LnR5cGUgPT09ICd0b2tlbicpIHtcbiAgICAgIHRva2VuID0gZmlyc3QudG9rZW47XG4gICAgICBpID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UgbmV2ZXIgaGF2ZSB0d28gc3RyaW5ncyBpbiBhIHJvd1xuICAgICAgdG9rZW4gPSAodGhpcy5mcmFnbWVudHNbMV0gYXMgVG9rZW5GcmFnbWVudCkudG9rZW4uY29uY2F0KGZpcnN0LnN0ciwgdW5kZWZpbmVkKTtcbiAgICAgIGkgPSAyO1xuICAgIH1cblxuICAgIHdoaWxlIChpIDwgdGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICB0b2tlbiA9IHRva2VuLmNvbmNhdCh1bmRlZmluZWQsIHJlc29sdmVGcmFnbWVudCh0aGlzLmZyYWdtZW50c1tpXSkpO1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiByZXNvbHZlKHRva2VuKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlc29sdmUgdGhlIHZhbHVlIGZyb20gYSBzaW5nbGUgZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZyYWdtZW50KGZyYWdtZW50OiBGcmFnbWVudCk6IGFueSB7XG4gIHJldHVybiBmcmFnbWVudC50eXBlID09PSAnc3RyaW5nJyA/IGZyYWdtZW50LnN0ciA6IHJlc29sdmUoZnJhZ21lbnQudG9rZW4pO1xufVxuXG4vKipcbiAqIFF1b3RlIGEgc3RyaW5nIGZvciB1c2UgaW4gYSByZWdleFxuICovXG5mdW5jdGlvbiByZWdleFF1b3RlKHM6IHN0cmluZykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2csIFwiXFxcXCQmXCIpO1xufVxuIl19