/**
 * If objects has a function property by this name, they will be considered tokens, and this
 * function will be called to resolve the value for this object.
 */
export declare const RESOLVE_METHOD = "resolve";
/**
 * Represents a special or lazily-evaluated value.
 *
 * Can be used to delay evaluation of a certain value in case, for example,
 * that it requires some context or late-bound data. Can also be used to
 * mark values that need special processing at document rendering time.
 *
 * Tokens can be embedded into strings while retaining their original
 * semantics.
 */
export declare class Token {
    private readonly valueOrFunction?;
    private readonly displayName?;
    private tokenKey?;
    /**
     * Creates a token that resolves to `value`.
     *
     * If value is a function, the function is evaluated upon resolution and
     * the value it returns will be used as the token's value.
     *
     * displayName is used to represent the Token when it's embedded into a string; it
     * will look something like this:
     *
     *    "embedded in a larger string is ${Token[DISPLAY_NAME.123]}"
     *
     * This value is used as a hint to humans what the meaning of the Token is,
     * and does not have any effect on the evaluation.
     *
     * Must contain only alphanumeric and simple separator characters (_.:-).
     *
     * @param valueOrFunction What this token will evaluate to, literal or function.
     * @param displayName A human-readable display hint for this Token
     */
    constructor(valueOrFunction?: any, displayName?: string | undefined);
    /**
     * @returns The resolved value for this token.
     */
    resolve(): any;
    /**
     * Return a reversible string representation of this token
     *
     * If the Token is initialized with a literal, the stringified value of the
     * literal is returned. Otherwise, a special quoted string representation
     * of the Token is returned that can be embedded into other strings.
     *
     * Strings with quoted Tokens in them can be restored back into
     * complex values with the Tokens restored by calling `resolve()`
     * on the string.
     */
    toString(): string;
    /**
     * Turn this Token into JSON
     *
     * This gets called by JSON.stringify(). We want to prohibit this, because
     * it's not possible to do this properly, so we just throw an error here.
     */
    toJSON(): any;
    /**
     * Return a concated version of this Token in a string context
     *
     * The default implementation of this combines strings, but specialized
     * implements of Token can return a more appropriate value.
     */
    concat(left: any | undefined, right: any | undefined): Token;
}
/**
 * Returns true if obj is a token (i.e. has the resolve() method or is a string
 * that includes token markers).
 * @param obj The object to test.
 */
export declare function unresolved(obj: any): boolean;
/**
 * Resolves an object by evaluating all tokens and removing any undefined or empty objects or arrays.
 * Values can only be primitives, arrays or tokens. Other objects (i.e. with methods) will be rejected.
 *
 * @param obj The object to resolve.
 * @param prefix Prefix key path components for diagnostics.
 */
export declare function resolve(obj: any, prefix?: string[]): any;
/**
 * Interface that Token joiners implement
 */
export interface ITokenJoiner {
    /**
     * The name of the joiner.
     *
     * Must be unique per joiner: this value will be used to assert that there
     * is exactly only type of joiner in a join operation.
     */
    id: string;
    /**
     * Return the language intrinsic that will combine the strings in the given engine
     */
    join(fragments: any[]): any;
}
