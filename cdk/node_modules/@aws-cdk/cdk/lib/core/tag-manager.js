"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tokens_1 = require("./tokens");
/**
 * TagManager facilitates a common implementation of tagging for Constructs.
 *
 * Each construct that wants to support tags should implement the `ITaggable`
 * interface and properly pass tags to the `Resources` (Cloudformation) elements
 * the `Construct` creates. The `TagManager` extends `Token` the object can be
 * passed directly to `Resources` that support tag properties.
 *
 * There are a few standard use cases the `TagManager` supports for managing
 * tags across the resources in your stack.
 *
 * Propagation: If you tag a resource and it has children, by default those tags
 * will be propagated to the children. This is controlled by
 * `TagProps.propagate`.
 *
 * Default a tag unless an ancestor has a value: There are situations where a
 * construct author might want to set a tag value, but choose to take a parents
 * value. For example, you might default `{Key: "Compliance", Value: "None"}`,
 * but if a parent has `{Key: "Compliance", Value: "PCI"}` allow that parent to
 * override your tag. This is can be done by setting `TagProps.sticky` to false.
 * The default behavior is that child tags have precedence and `TagProps.sticky`
 * defaults to true to reflect this.
 *
 * Overwrite: Construct authors have the need to set a tag, but only if one was
 * not provided by the consumer. The most common example is the `Name` tag.
 * Overwrite is for this purpose and is controlled by `TagProps.overwrite`. The
 * default is `true`.
 *
 * Removing Tags: Tags can be removed from the local manager via `removeTag`. If
 * a parent also has a tag with the same name then it can be propagated to the
 * child (after removal). The user can control this `RemoveProps.blockPropagate`. By default
 * this is `true` and prevents a parent tag from propagating to the child after
 * the `removeTag` is invoked. However, if user wants the parent tag to
 * propagate, if it is provided by a parent this can be set to `false`.
 */
class TagManager extends tokens_1.Token {
    constructor(parent, props = {}) {
        super();
        this.parent = parent;
        /*
         * Internally tags will have properties set
         */
        this._tags = {};
        /*
         * Tags that will be removed during `tags` method
         */
        this.blockedTags = [];
        const initialTags = props.initialTags || {};
        for (const key of Object.keys(initialTags)) {
            const tag = {
                value: initialTags[key],
                props: TagManager.DEFAULT_TAG_PROPS,
            };
            this._tags[key] = tag;
        }
    }
    /**
     * Checks if the object implements the `ITaggable` interface
     */
    static isTaggable(taggable) {
        return (taggable.tags !== undefined);
    }
    /**
     * Converts the `tags` to a Token for use in lazy evaluation
     */
    resolve() {
        // need this for scoping
        const blockedTags = this.blockedTags;
        function filterTags(_tags, filter = {}) {
            const filteredTags = {};
            Object.keys(_tags).map(key => {
                let filterResult = true;
                const props = _tags[key].props || {};
                if (filter.propagate !== undefined) {
                    filterResult = filterResult && (filter.propagate === props.propagate);
                }
                if (filter.sticky !== undefined) {
                    filterResult = filterResult &&
                        (filter.sticky === props.sticky);
                }
                if (filter.overwrite !== undefined) {
                    filterResult = filterResult && (filter.overwrite === props.overwrite);
                }
                if (filterResult) {
                    filteredTags[key] = _tags[key].value;
                }
            });
            for (const key of blockedTags) {
                delete filteredTags[key];
            }
            return filteredTags;
        }
        function propagatedTags(tagProviders) {
            const parentTags = {};
            for (const ancestor of tagProviders) {
                if (TagManager.isTaggable(ancestor)) {
                    const tagsFrom = filterTags(ancestor.tags._tags, { propagate: true });
                    Object.assign(parentTags, tagsFrom);
                }
            }
            for (const key of blockedTags) {
                delete parentTags[key];
            }
            return parentTags;
        }
        const nonStickyTags = filterTags(this._tags, { sticky: false });
        const stickyTags = filterTags(this._tags, { sticky: true });
        const ancestors = this.parent.ancestors();
        const ancestorTags = propagatedTags(ancestors);
        const propagateTags = filterTags(this._tags, { propagate: true });
        return this.tagFormatResolve({
            ancestorTags,
            nonStickyTags,
            stickyTags,
            propagateTags,
        });
    }
    /**
     * Adds the specified tag to the array of tags
     *
     * @param key The key value of the tag
     * @param value The value value of the tag
     * @param props A `TagProps` object for the tag @default `TagManager.DEFAULT_TAG_PROPS`
     */
    setTag(key, value, tagProps = {}) {
        const props = Object.assign({}, TagManager.DEFAULT_TAG_PROPS, tagProps);
        if (!props.overwrite) {
            this._tags[key] = this._tags[key] || { value, props };
        }
        else {
            this._tags[key] = { value, props };
        }
        const index = this.blockedTags.indexOf(key);
        if (index > -1) {
            this.blockedTags.splice(index, 1);
        }
    }
    /**
     * Removes the specified tag from the array if it exists
     *
     * @param key The key of the tag to remove
     * @param props The `RemoveProps` for the tag
     */
    removeTag(key, props = { blockPropagate: true }) {
        if (props.blockPropagate) {
            this.blockedTags.push(key);
        }
        delete this._tags[key];
    }
    /**
     * Handles returning the tags in the desired format
     *
     * This function can be overridden to support another tag format. This was
     * specifically designed to enable AutoScalingGroup Tags that have an
     * additional CloudFormation key for `PropagateAtLaunch`
     */
    tagFormatResolve(tagGroups) {
        const tags = Object.assign({}, tagGroups.nonStickyTags, tagGroups.ancestorTags, tagGroups.stickyTags);
        for (const key of this.blockedTags) {
            delete tags[key];
        }
        if (Object.keys(tags).length === 0) {
            return undefined;
        }
        return Object.keys(tags).map(key => ({ key, value: tags[key] }));
    }
}
TagManager.DEFAULT_TAG_PROPS = {
    propagate: true,
    sticky: true,
    overwrite: true
};
exports.TagManager = TagManager;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFnLW1hbmFnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ0YWctbWFuYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLHFDQUFpQztBQWdHakM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FrQ0c7QUFDSCxNQUFhLFVBQVcsU0FBUSxjQUFLO0lBeUJuQyxZQUE2QixNQUFpQixFQUFFLFFBQTBCLEVBQUU7UUFDMUUsS0FBSyxFQUFFLENBQUM7UUFEbUIsV0FBTSxHQUFOLE1BQU0sQ0FBVztRQVY5Qzs7V0FFRztRQUNjLFVBQUssR0FBYSxFQUFFLENBQUM7UUFFdEM7O1dBRUc7UUFDYyxnQkFBVyxHQUFhLEVBQUUsQ0FBQztRQUsxQyxNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsV0FBVyxJQUFJLEVBQUUsQ0FBQztRQUM1QyxLQUFLLE1BQU0sR0FBRyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUU7WUFDMUMsTUFBTSxHQUFHLEdBQUc7Z0JBQ1YsS0FBSyxFQUFFLFdBQVcsQ0FBQyxHQUFHLENBQUM7Z0JBQ3ZCLEtBQUssRUFBRSxVQUFVLENBQUMsaUJBQWlCO2FBQ3BDLENBQUM7WUFDRixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztTQUN2QjtJQUNILENBQUM7SUFsQ0Q7O09BRUc7SUFDSSxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQXlCO1FBQ2hELE9BQU8sQ0FBRSxRQUFzQixDQUFDLElBQUksS0FBSyxTQUFTLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBK0JEOztPQUVHO0lBQ0ksT0FBTztRQUNaLHdCQUF3QjtRQUN4QixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1FBQ3JDLFNBQVMsVUFBVSxDQUFDLEtBQWUsRUFBRSxTQUFtQixFQUFFO1lBQ3hELE1BQU0sWUFBWSxHQUFTLEVBQUUsQ0FBQztZQUM5QixNQUFNLENBQUMsSUFB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QUMsR0FBRyxDQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xFLENBQUM7O0FBbEl1Qiw0QkFBaUIsR0FBYTtJQUNwRCxTQUFTLEVBQUUsSUFBSTtJQUNmLE1BQU0sRUFBRSxJQUFJO0lBQ1osU0FBUyxFQUFFLElBQUk7Q0FDaEIsQ0FBQztBQWJKLGdDQTRJQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJy4vY29uc3RydWN0JztcbmltcG9ydCB7IFRva2VuIH0gZnJvbSAnLi90b2tlbnMnO1xuXG4vKipcbiAqIElUYWdnYWJsZSBpbmRpY2F0ZXMgYSBlbnRpdHkgbWFuYWdlcyB0YWdzIHZpYSB0aGUgYHRhZ3NgIHByb3BlcnR5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVRhZ2dhYmxlIHtcbiAgcmVhZG9ubHkgdGFnczogVGFnTWFuYWdlcixcbn1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIFRhZ3MgaXMgYSBkaWN0aW9uYXJ5IG9mIHRhZ3MgYXMgc3RyaW5nc1xuICovXG5leHBvcnQgdHlwZSBUYWdzID0geyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcblxuLyoqXG4gKiBBbiBvYmplY3Qgb2YgdGFncyB3aXRoIHZhbHVlIGFuZCBwcm9wZXJ0aWVzXG4gKlxuICogVGhpcyBpcyB1c2VkIGludGVybmFsbHkgYnV0IG5vdCBleHBvcnRlZFxuICovXG5pbnRlcmZhY2UgRnVsbFRhZ3Mge1xuICBba2V5OiBzdHJpbmddOiB7dmFsdWU6IHN0cmluZywgcHJvcHM/OiBUYWdQcm9wc307XG59XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgYSB0YWdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUYWdQcm9wcyB7XG4gIC8qKlxuICAgKiBJZiB0cnVlIGFsbCBjaGlsZCB0YWdnYWJsZSBgQ29uc3RydWN0c2Agd2lsbCByZWNlaXZlIHRoaXMgdGFnXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHByb3BhZ2F0ZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIElmIHNldCBwcm9wYWdhdGVkIHRhZ3MgZnJvbSBwYXJlbnRzIHdpbGwgbm90IG92ZXJ3cml0ZSB0aGUgdGFnXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHN0aWNreT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIElmIHNldCB0aGlzIHRhZyB3aWxsIG92ZXJ3cml0ZSBleGlzdGluZyB0YWdzXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIG92ZXJ3cml0ZT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgaW50ZXJmYWNlIGZvciBhcmd1bWVudHMgdG8gYHRhZ0Zvcm1hdFJlc29sdmVgIHRvIGVuYWJsZSBleHRlbnNpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGFnR3JvdXBzIHtcbiAgLyoqXG4gICAqIFRhZ3MgdGhhdCBvdmVyd3JpdGUgYW5jZXN0b3IgdGFnc1xuICAgKi9cbiAgc3RpY2t5VGFnczogVGFncztcblxuICAvKipcbiAgICogVGFncyB0aGF0IGFyZSBvdmVyd3JpdHRlbiBieSBhbmNlc3RvciB0YWdzXG4gICAqL1xuICBub25TdGlja3lUYWdzOiBUYWdzO1xuXG4gIC8qKlxuICAgKiBUYWdzIHdpdGggcHJvcGFnYXRlIHRydWUgbm90IGZyb20gYW4gYW5jZXN0b3JcbiAgICovXG4gIHByb3BhZ2F0ZVRhZ3M6IFRhZ3M7XG5cbiAgLyoqXG4gICAqIFRhZ3MgdGhhdCBhcmUgcHJvcGFnYXRlZCBmcm9tIGFuY2VzdG9yc1xuICAgKi9cbiAgYW5jZXN0b3JUYWdzOiBUYWdzO1xufVxuXG4vKipcbiAqIFByb3BlcnRpZXMgZm9yIHJlbW92aW5nIHRhZ3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZW1vdmVQcm9wcyB7XG4gIC8qKlxuICAgKiBJZiB0cnVlIHByZXZlbnQgdGhpcyB0YWcgZm9ybSBiZWluZyBzZXQgdmlhIHByb3BhZ2F0aW9uXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGJsb2NrUHJvcGFnYXRlPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIGZvciBUYWcgTWFuYWdlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRhZ01hbmFnZXJQcm9wcyB7XG4gIC8qKlxuICAgKiBJbml0aWFsIHRhZ3MgdG8gc2V0IG9uIHRoZSB0YWcgbWFuYWdlciB1c2luZyBUQUdfREVGQVVMVFNcbiAgICovXG4gIGluaXRpYWxUYWdzPzogVGFncztcbn1cblxuLyoqXG4gKiBUYWdNYW5hZ2VyIGZhY2lsaXRhdGVzIGEgY29tbW9uIGltcGxlbWVudGF0aW9uIG9mIHRhZ2dpbmcgZm9yIENvbnN0cnVjdHMuXG4gKlxuICogRWFjaCBjb25zdHJ1Y3QgdGhhdCB3YW50cyB0byBzdXBwb3J0IHRhZ3Mgc2hvdWxkIGltcGxlbWVudCB0aGUgYElUYWdnYWJsZWBcbiAqIGludGVyZmFjZSBhbmQgcHJvcGVybHkgcGFzcyB0YWdzIHRvIHRoZSBgUmVzb3VyY2VzYCAoQ2xvdWRmb3JtYXRpb24pIGVsZW1lbnRzXG4gKiB0aGUgYENvbnN0cnVjdGAgY3JlYXRlcy4gVGhlIGBUYWdNYW5hZ2VyYCBleHRlbmRzIGBUb2tlbmAgdGhlIG9iamVjdCBjYW4gYmVcbiAqIHBhc3NlZCBkaXJlY3RseSB0byBgUmVzb3VyY2VzYCB0aGF0IHN1cHBvcnQgdGFnIHByb3BlcnRpZXMuXG4gKlxuICogVGhlcmUgYXJlIGEgZmV3IHN0YW5kYXJkIHVzZSBjYXNlcyB0aGUgYFRhZ01hbmFnZXJgIHN1cHBvcnRzIGZvciBtYW5hZ2luZ1xuICogdGFncyBhY3Jvc3MgdGhlIHJlc291cmNlcyBpbiB5b3VyIHN0YWNrLlxuICpcbiAqIFByb3BhZ2F0aW9uOiBJZiB5b3UgdGFnIGEgcmVzb3VyY2UgYW5kIGl0IGhhcyBjaGlsZHJlbiwgYnkgZGVmYXVsdCB0aG9zZSB0YWdzXG4gKiB3aWxsIGJlIHByb3BhZ2F0ZWQgdG8gdGhlIGNoaWxkcmVuLiBUaGlzIGlzIGNvbnRyb2xsZWQgYnlcbiAqIGBUYWdQcm9wcy5wcm9wYWdhdGVgLlxuICpcbiAqIERlZmF1bHQgYSB0YWcgdW5sZXNzIGFuIGFuY2VzdG9yIGhhcyBhIHZhbHVlOiBUaGVyZSBhcmUgc2l0dWF0aW9ucyB3aGVyZSBhXG4gKiBjb25zdHJ1Y3QgYXV0aG9yIG1pZ2h0IHdhbnQgdG8gc2V0IGEgdGFnIHZhbHVlLCBidXQgY2hvb3NlIHRvIHRha2UgYSBwYXJlbnRzXG4gKiB2YWx1ZS4gRm9yIGV4YW1wbGUsIHlvdSBtaWdodCBkZWZhdWx0IGB7S2V5OiBcIkNvbXBsaWFuY2VcIiwgVmFsdWU6IFwiTm9uZVwifWAsXG4gKiBidXQgaWYgYSBwYXJlbnQgaGFzIGB7S2V5OiBcIkNvbXBsaWFuY2VcIiwgVmFsdWU6IFwiUENJXCJ9YCBhbGxvdyB0aGF0IHBhcmVudCB0b1xuICogb3ZlcnJpZGUgeW91ciB0YWcuIFRoaXMgaXMgY2FuIGJlIGRvbmUgYnkgc2V0dGluZyBgVGFnUHJvcHMuc3RpY2t5YCB0byBmYWxzZS5cbiAqIFRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHRoYXQgY2hpbGQgdGFncyBoYXZlIHByZWNlZGVuY2UgYW5kIGBUYWdQcm9wcy5zdGlja3lgXG4gKiBkZWZhdWx0cyB0byB0cnVlIHRvIHJlZmxlY3QgdGhpcy5cbiAqXG4gKiBPdmVyd3JpdGU6IENvbnN0cnVjdCBhdXRob3JzIGhhdmUgdGhlIG5lZWQgdG8gc2V0IGEgdGFnLCBidXQgb25seSBpZiBvbmUgd2FzXG4gKiBub3QgcHJvdmlkZWQgYnkgdGhlIGNvbnN1bWVyLiBUaGUgbW9zdCBjb21tb24gZXhhbXBsZSBpcyB0aGUgYE5hbWVgIHRhZy5cbiAqIE92ZXJ3cml0ZSBpcyBmb3IgdGhpcyBwdXJwb3NlIGFuZCBpcyBjb250cm9sbGVkIGJ5IGBUYWdQcm9wcy5vdmVyd3JpdGVgLiBUaGVcbiAqIGRlZmF1bHQgaXMgYHRydWVgLlxuICpcbiAqIFJlbW92aW5nIFRhZ3M6IFRhZ3MgY2FuIGJlIHJlbW92ZWQgZnJvbSB0aGUgbG9jYWwgbWFuYWdlciB2aWEgYHJlbW92ZVRhZ2AuIElmXG4gKiBhIHBhcmVudCBhbHNvIGhhcyBhIHRhZyB3aXRoIHRoZSBzYW1lIG5hbWUgdGhlbiBpdCBjYW4gYmUgcHJvcGFnYXRlZCB0byB0aGVcbiAqIGNoaWxkIChhZnRlciByZW1vdmFsKS4gVGhlIHVzZXIgY2FuIGNvbnRyb2wgdGhpcyBgUmVtb3ZlUHJvcHMuYmxvY2tQcm9wYWdhdGVgLiBCeSBkZWZhdWx0XG4gKiB0aGlzIGlzIGB0cnVlYCBhbmQgcHJldmVudHMgYSBwYXJlbnQgdGFnIGZyb20gcHJvcGFnYXRpbmcgdG8gdGhlIGNoaWxkIGFmdGVyXG4gKiB0aGUgYHJlbW92ZVRhZ2AgaXMgaW52b2tlZC4gSG93ZXZlciwgaWYgdXNlciB3YW50cyB0aGUgcGFyZW50IHRhZyB0b1xuICogcHJvcGFnYXRlLCBpZiBpdCBpcyBwcm92aWRlZCBieSBhIHBhcmVudCB0aGlzIGNhbiBiZSBzZXQgdG8gYGZhbHNlYC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhZ01hbmFnZXIgZXh0ZW5kcyBUb2tlbiB7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgb2JqZWN0IGltcGxlbWVudHMgdGhlIGBJVGFnZ2FibGVgIGludGVyZmFjZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBpc1RhZ2dhYmxlKHRhZ2dhYmxlOiBJVGFnZ2FibGUgfCBhbnkpOiB0YWdnYWJsZSBpcyBJVGFnZ2FibGUge1xuICAgIHJldHVybiAoKHRhZ2dhYmxlIGFzIElUYWdnYWJsZSkudGFncyAhPT0gdW5kZWZpbmVkKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfVEFHX1BST1BTOiBUYWdQcm9wcyA9IHtcbiAgICBwcm9wYWdhdGU6IHRydWUsXG4gICAgc3RpY2t5OiB0cnVlLFxuICAgIG92ZXJ3cml0ZTogdHJ1ZVxuICB9O1xuXG4gIC8qXG4gICAqIEludGVybmFsbHkgdGFncyB3aWxsIGhhdmUgcHJvcGVydGllcyBzZXRcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgX3RhZ3M6IEZ1bGxUYWdzID0ge307XG5cbiAgLypcbiAgICogVGFncyB0aGF0IHdpbGwgYmUgcmVtb3ZlZCBkdXJpbmcgYHRhZ3NgIG1ldGhvZFxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBibG9ja2VkVGFnczogc3RyaW5nW10gPSBbXTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHBhcmVudDogQ29uc3RydWN0LCBwcm9wczogVGFnTWFuYWdlclByb3BzICA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnN0IGluaXRpYWxUYWdzID0gcHJvcHMuaW5pdGlhbFRhZ3MgfHwge307XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaW5pdGlhbFRhZ3MpKSB7XG4gICAgICBjb25zdCB0YWcgPSB7XG4gICAgICAgIHZhbHVlOiBpbml0aWFsVGFnc1trZXldLFxuICAgICAgICBwcm9wczogVGFnTWFuYWdlci5ERUZBVUxUX1RBR19QUk9QUyxcbiAgICAgIH07XG4gICAgICB0aGlzLl90YWdzW2tleV0gPSB0YWc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBgdGFnc2AgdG8gYSBUb2tlbiBmb3IgdXNlIGluIGxhenkgZXZhbHVhdGlvblxuICAgKi9cbiAgcHVibGljIHJlc29sdmUoKTogYW55IHtcbiAgICAvLyBuZWVkIHRoaXMgZm9yIHNjb3BpbmdcbiAgICBjb25zdCBibG9ja2VkVGFncyA9IHRoaXMuYmxvY2tlZFRhZ3M7XG4gICAgZnVuY3Rpb24gZmlsdGVyVGFncyhfdGFnczogRnVsbFRhZ3MsIGZpbHRlcjogVGFnUHJvcHMgPSB7fSk6IFRhZ3Mge1xuICAgICAgY29uc3QgZmlsdGVyZWRUYWdzOiBUYWdzID0ge307XG4gICAgICBPYmplY3Qua2V5cyhfdGFncykubWFwKCBrZXkgPT4ge1xuICAgICAgICBsZXQgZmlsdGVyUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcHJvcHM6IFRhZ1Byb3BzID0gX3RhZ3Nba2V5XS5wcm9wcyB8fCB7fTtcbiAgICAgICAgaWYgKGZpbHRlci5wcm9wYWdhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZpbHRlclJlc3VsdCA9IGZpbHRlclJlc3VsdCAmJiAoZmlsdGVyLnByb3BhZ2F0ZSA9PT0gcHJvcHMucHJvcGFnYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyLnN0aWNreSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZmlsdGVyUmVzdWx0ID0gZmlsdGVyUmVzdWx0ICYmXG4gICAgICAgICAgICAoZmlsdGVyLnN0aWNreSA9PT0gcHJvcHMuc3RpY2t5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyLm92ZXJ3cml0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZmlsdGVyUmVzdWx0ID0gZmlsdGVyUmVzdWx0ICYmIChmaWx0ZXIub3ZlcndyaXRlID09PSBwcm9wcy5vdmVyd3JpdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXJSZXN1bHQpIHtcbiAgICAgICAgICBmaWx0ZXJlZFRhZ3Nba2V5XSA9IF90YWdzW2tleV0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgYmxvY2tlZFRhZ3MpIHsgZGVsZXRlIGZpbHRlcmVkVGFnc1trZXldOyB9XG4gICAgICByZXR1cm4gZmlsdGVyZWRUYWdzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZWRUYWdzKHRhZ1Byb3ZpZGVyczogQ29uc3RydWN0W10pOiBUYWdzIHtcbiAgICAgIGNvbnN0IHBhcmVudFRhZ3M6IFRhZ3MgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgYW5jZXN0b3Igb2YgdGFnUHJvdmlkZXJzKSB7XG4gICAgICAgIGlmIChUYWdNYW5hZ2VyLmlzVGFnZ2FibGUoYW5jZXN0b3IpKSB7XG4gICAgICAgICAgY29uc3QgdGFnc0Zyb20gPSBmaWx0ZXJUYWdzKGFuY2VzdG9yLnRhZ3MuX3RhZ3MsIHtwcm9wYWdhdGU6IHRydWV9KTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcmVudFRhZ3MsIHRhZ3NGcm9tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgYmxvY2tlZFRhZ3MpIHsgZGVsZXRlIHBhcmVudFRhZ3Nba2V5XTsgfVxuICAgICAgcmV0dXJuIHBhcmVudFRhZ3M7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9uU3RpY2t5VGFncyA9IGZpbHRlclRhZ3ModGhpcy5fdGFncywge3N0aWNreTogZmFsc2V9KTtcbiAgICBjb25zdCBzdGlja3lUYWdzID0gZmlsdGVyVGFncyh0aGlzLl90YWdzLCB7c3RpY2t5OiB0cnVlfSk7XG4gICAgY29uc3QgYW5jZXN0b3JzID0gdGhpcy5wYXJlbnQuYW5jZXN0b3JzKCk7XG4gICAgY29uc3QgYW5jZXN0b3JUYWdzID0gcHJvcGFnYXRlZFRhZ3MoYW5jZXN0b3JzKTtcbiAgICBjb25zdCBwcm9wYWdhdGVUYWdzID0gZmlsdGVyVGFncyh0aGlzLl90YWdzLCB7cHJvcGFnYXRlOiB0cnVlfSk7XG4gICAgcmV0dXJuIHRoaXMudGFnRm9ybWF0UmVzb2x2ZSgge1xuICAgICAgYW5jZXN0b3JUYWdzLFxuICAgICAgbm9uU3RpY2t5VGFncyxcbiAgICAgIHN0aWNreVRhZ3MsXG4gICAgICBwcm9wYWdhdGVUYWdzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIHNwZWNpZmllZCB0YWcgdG8gdGhlIGFycmF5IG9mIHRhZ3NcbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IHZhbHVlIG9mIHRoZSB0YWdcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB2YWx1ZSBvZiB0aGUgdGFnXG4gICAqIEBwYXJhbSBwcm9wcyBBIGBUYWdQcm9wc2Agb2JqZWN0IGZvciB0aGUgdGFnIEBkZWZhdWx0IGBUYWdNYW5hZ2VyLkRFRkFVTFRfVEFHX1BST1BTYFxuICAgKi9cbiAgcHVibGljIHNldFRhZyhrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZywgdGFnUHJvcHM6IFRhZ1Byb3BzID0ge30pOiB2b2lkIHtcbiAgICBjb25zdCBwcm9wcyA9IHsuLi5UYWdNYW5hZ2VyLkRFRkFVTFRfVEFHX1BST1BTLCAuLi50YWdQcm9wc307XG4gICAgaWYgKCFwcm9wcy5vdmVyd3JpdGUpIHtcbiAgICAgIHRoaXMuX3RhZ3Nba2V5XSA9IHRoaXMuX3RhZ3Nba2V5XSB8fCB7dmFsdWUsIHByb3BzfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGFnc1trZXldID0ge3ZhbHVlLCBwcm9wc307XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5ibG9ja2VkVGFncy5pbmRleE9mKGtleSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHRoaXMuYmxvY2tlZFRhZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIHRhZyBmcm9tIHRoZSBhcnJheSBpZiBpdCBleGlzdHNcbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSB0YWcgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSBwcm9wcyBUaGUgYFJlbW92ZVByb3BzYCBmb3IgdGhlIHRhZ1xuICAgKi9cbiAgcHVibGljIHJlbW92ZVRhZyhrZXk6IHN0cmluZywgcHJvcHM6IFJlbW92ZVByb3BzID0ge2Jsb2NrUHJvcGFnYXRlOiB0cnVlfSk6IHZvaWQge1xuICAgIGlmIChwcm9wcy5ibG9ja1Byb3BhZ2F0ZSkge1xuICAgICAgdGhpcy5ibG9ja2VkVGFncy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLl90YWdzW2tleV07XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyByZXR1cm5pbmcgdGhlIHRhZ3MgaW4gdGhlIGRlc2lyZWQgZm9ybWF0XG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIG92ZXJyaWRkZW4gdG8gc3VwcG9ydCBhbm90aGVyIHRhZyBmb3JtYXQuIFRoaXMgd2FzXG4gICAqIHNwZWNpZmljYWxseSBkZXNpZ25lZCB0byBlbmFibGUgQXV0b1NjYWxpbmdHcm91cCBUYWdzIHRoYXQgaGF2ZSBhblxuICAgKiBhZGRpdGlvbmFsIENsb3VkRm9ybWF0aW9uIGtleSBmb3IgYFByb3BhZ2F0ZUF0TGF1bmNoYFxuICAgKi9cbiAgcHJvdGVjdGVkIHRhZ0Zvcm1hdFJlc29sdmUodGFnR3JvdXBzOiBUYWdHcm91cHMpOiBhbnkge1xuICAgIGNvbnN0IHRhZ3MgPSB7Li4udGFnR3JvdXBzLm5vblN0aWNreVRhZ3MsIC4uLnRhZ0dyb3Vwcy5hbmNlc3RvclRhZ3MsIC4uLnRhZ0dyb3Vwcy5zdGlja3lUYWdzfTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmJsb2NrZWRUYWdzKSB7IGRlbGV0ZSB0YWdzW2tleV07IH1cbiAgICBpZiAoT2JqZWN0LmtleXModGFncykubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXModGFncykubWFwKCBrZXkgPT4gKHtrZXksIHZhbHVlOiB0YWdzW2tleV19KSk7XG4gIH1cbn1cbiJdfQ==