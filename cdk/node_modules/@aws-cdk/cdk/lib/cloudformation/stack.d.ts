import cxapi = require('@aws-cdk/cx-api');
import { App } from '../app';
import { Construct } from '../core/construct';
import { Environment } from '../environment';
import { CloudFormationToken } from './cloudformation-token';
import { IAddressingScheme, LogicalIDs } from './logical-id';
import { Resource } from './resource';
export interface StackProps {
    /**
     * The AWS environment (account/region) where this stack will be deployed.
     *
     * If not supplied, the `default-account` and `default-region` context parameters will be
     * used. If they are undefined, it will not be possible to deploy the stack.
     */
    env?: Environment;
    /**
     * Strategy for logical ID generation
     *
     * Optional. If not supplied, the HashedNamingScheme will be used.
     */
    namingScheme?: IAddressingScheme;
}
/**
 * A root construct which represents a single CloudFormation stack.
 */
export declare class Stack extends Construct {
    /**
     * Traverses the tree and looks up for the Stack root.
     * @param node A construct in the tree
     * @returns The Stack object (throws if the node is not part of a Stack-rooted tree)
     */
    static find(node: Construct): Stack;
    /**
     * Adds a metadata annotation "aws:cdk:physical-name" to the construct if physicalName
     * is non-null. This can be used later by tools and aspects to determine if resources
     * have been created with physical names.
     */
    static annotatePhysicalName(construct: Construct, physicalName?: string): void;
    private static readonly VALID_STACK_NAME_REGEX;
    /**
     * Lists all missing contextual information.
     * This is returned when the stack is synthesized under the 'missing' attribute
     * and allows tooling to obtain the context and re-synthesize.
     */
    readonly missingContext: {
        [key: string]: cxapi.MissingContext;
    };
    /**
     * The environment in which this stack is deployed.
     */
    readonly env: Environment;
    /**
     * Used to determine if this construct is a stack.
     */
    readonly isStack = true;
    /**
     * Logical ID generation strategy
     */
    readonly logicalIds: LogicalIDs;
    /**
     * Options for CloudFormation template (like version, transform, description).
     */
    readonly templateOptions: TemplateOptions;
    /**
     * The CloudFormation stack name.
     */
    readonly name: string;
    /**
     * Creates a new stack.
     *
     * @param parent Parent of this stack, usually a Program instance.
     * @param name The name of the CloudFormation stack. Defaults to "Stack".
     * @param props Stack properties.
     */
    constructor(parent?: App, name?: string, props?: StackProps);
    /**
     * Looks up a resource by path.
     *
     * @returns The Resource or undefined if not found
     */
    findResource(path: string): Resource | undefined;
    /**
     * Returns the CloudFormation template for this stack by traversing
     * the tree and invoking toCloudFormation() on all Entity objects.
     */
    toCloudFormation(): any;
    /**
     * @param why more information about why region is required.
     * @returns The region in which this stack is deployed. Throws if region is not defined.
     */
    requireRegion(why?: string): string;
    /**
     * Indicate that a context key was expected
     *
     * Contains instructions on how the key should be supplied.
     * @param key Key that uniquely identifies this missing context.
     * @param details The set of parameters needed to obtain the context (specific to context provider).
     */
    reportMissingContext(key: string, details: cxapi.MissingContext): void;
    /**
     * Rename a generated logical identities
     */
    renameLogical(oldId: string, newId: string): void;
    /**
     * Validate stack name
     *
     * CloudFormation stack names can include dashes in addition to the regular identifier
     * character classes, and we don't allow one of the magic markers.
     */
    protected _validateId(name: string): void;
    /**
     * Applied defaults to environment attributes.
     */
    private parseEnvironment;
}
/**
 * Represents a construct that can be "depended on" via `addDependency`.
 */
export interface IDependable {
    /**
     * Returns the set of all stack elements (resources, parameters, conditions)
     * that should be added when a resource "depends on" this construct.
     */
    readonly dependencyElements: IDependable[];
}
/**
 * An element of a CloudFormation stack.
 */
export declare abstract class StackElement extends Construct implements IDependable {
    /**
     * Returns `true` if a construct is a stack element (i.e. part of the
     * synthesized cloudformation template).
     *
     * Uses duck-typing instead of `instanceof` to allow stack elements from different
     * versions of this library to be included in the same stack.
     *
     * @returns The construct as a stack element or undefined if it is not a stack element.
     */
    static _asStackElement(construct: Construct): StackElement | undefined;
    /**
     * The logical ID for this CloudFormation stack element
     */
    readonly logicalId: string;
    /**
     * The stack this Construct has been made a part of
     */
    protected stack: Stack;
    /**
     * Creates an entity and binds it to a tree.
     * Note that the root of the tree must be a Stack object (not just any Root).
     *
     * @param parent The parent construct
     * @param props Construct properties
     */
    constructor(parent: Construct, name: string);
    /**
     * @returns the stack trace of the point where this Resource was created from, sourced
     *      from the +metadata+ entry typed +aws:cdk:logicalId+, and with the bottom-most
     *      node +internal+ entries filtered.
     */
    readonly creationStackTrace: string[];
    /**
     * Return the path with respect to the stack
     */
    readonly stackPath: string;
    readonly dependencyElements: IDependable[];
    /**
     * Returns the CloudFormation 'snippet' for this entity. The snippet will only be merged
     * at the root level to ensure there are no identity conflicts.
     *
     * For example, a Resource class will return something like:
     * {
     *   Resources: {
     *     [this.logicalId]: {
     *       Type: this.resourceType,
     *       Properties: this.props,
     *       Condition: this.condition
     *     }
     *   }
     * }
     */
    abstract toCloudFormation(): object;
}
/**
 * CloudFormation template options for a stack.
 */
export interface TemplateOptions {
    /**
     * Gets or sets the description of this stack.
     * If provided, it will be included in the CloudFormation template's "Description" attribute.
     */
    description?: string;
    /**
     * Gets or sets the AWSTemplateFormatVersion field of the CloudFormation template.
     */
    templateFormatVersion?: string;
    /**
     * Gets or sets the top-level template transform for this stack (e.g. "AWS::Serverless-2016-10-31").
     */
    transform?: string;
    /**
     * Metadata associated with the CloudFormation template.
     */
    metadata?: {
        [key: string]: any;
    };
}
/**
 * Base class for referenceable CloudFormation constructs which are not Resources
 *
 * These constructs are things like Conditions and Parameters, can be
 * referenced by taking the `.ref` attribute.
 *
 * Resource constructs do not inherit from Referenceable because they have their
 * own, more specific types returned from the .ref attribute. Also, some
 * resources aren't referenceable at all (such as BucketPolicies or GatewayAttachments).
 */
export declare abstract class Referenceable extends StackElement {
    /**
     * Returns a token to a CloudFormation { Ref } that references this entity based on it's logical ID.
     */
    readonly ref: string;
}
/**
 * A generic, untyped reference to a Stack Element
 */
export declare class Ref extends CloudFormationToken {
    constructor(element: StackElement);
}
