"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const fn_1 = require("../cloudformation/fn");
const tokens_1 = require("../core/tokens");
const cloudformation_token_1 = require("./cloudformation-token");
/**
 * An Amazon Resource Name (ARN).
 * http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html
 */
class ArnUtils {
    /**
     * Creates an ARN from components.
     *
     * If `partition`, `region` or `account` are not specified, the stack's
     * partition, region and account will be used.
     *
     * If any component is the empty string, an empty string will be inserted
     * into the generated ARN at the location that component corresponds to.
     *
     * The ARN will be formatted as follows:
     *
     *   arn:{partition}:{service}:{region}:{account}:{resource}{sep}}{resource-name}
     *
     */
    static fromComponents(components) {
        const partition = components.partition == null
            ? new __1.AwsPartition()
            : components.partition;
        const region = components.region == null
            ? new __1.AwsRegion()
            : components.region;
        const account = components.account == null
            ? new __1.AwsAccountId()
            : components.account;
        const values = ['arn', ':', partition, ':', components.service, ':', region, ':', account, ':', components.resource];
        const sep = components.sep || '/';
        if (sep !== '/' && sep !== ':') {
            throw new Error('resourcePathSep may only be ":" or "/"');
        }
        if (components.resourceName != null) {
            values.push(sep);
            values.push(components.resourceName);
        }
        return new __1.FnConcat(...values).toString();
    }
    /**
     * Given an ARN, parses it and returns components.
     *
     * If the ARN is a concrete string, it will be parsed and validated. The
     * separator (`sep`) will be set to '/' if the 6th component includes a '/',
     * in which case, `resource` will be set to the value before the '/' and
     * `resourceName` will be the rest. In case there is no '/', `resource` will
     * be set to the 6th components and `resourceName` will be set to the rest
     * of the string.
     *
     * If the ARN includes tokens (or is a token), the ARN cannot be validated,
     * since we don't have the actual value yet at the time of this function
     * call. You will have to know the separator and the type of ARN. The
     * resulting `ArnComponents` object will contain tokens for the
     * subexpressions of the ARN, not string literals. In this case this
     * function cannot properly parse the complete final resourceName (path) out
     * of ARNs that use '/' to both separate the 'resource' from the
     * 'resourceName' AND to subdivide the resourceName further. For example, in
     * S3 ARNs:
     *
     *    arn:aws:s3:::my_corporate_bucket/path/to/exampleobject.png
     *
     * After parsing the resourceName will not contain
     * 'path/to/exampleobject.png' but simply 'path'. This is a limitation
     * because there is no slicing functionality in CloudFormation templates.
     *
     * @param sep The separator used to separate resource from resourceName
     * @param hasName Whether there is a name component in the ARN at all. For
     * example, SNS Topics ARNs have the 'resource' component contain the topic
     * name, and no 'resourceName' component.
     *
     * @returns an ArnComponents object which allows access to the various
     * components of the ARN.
     *
     * @returns an ArnComponents object which allows access to the various
     *      components of the ARN.
     */
    static parse(arn, sepIfToken = '/', hasName = true) {
        if (tokens_1.unresolved(arn)) {
            return ArnUtils.parseToken(new cloudformation_token_1.CloudFormationToken(arn), sepIfToken, hasName);
        }
        const components = arn.split(':');
        if (components.length < 6) {
            throw new Error('ARNs must have at least 6 components: ' + arn);
        }
        const [arnPrefix, partition, service, region, account, sixth, ...rest] = components;
        if (arnPrefix !== 'arn') {
            throw new Error('ARNs must start with "arn:": ' + arn);
        }
        if (!service) {
            throw new Error('The `service` component (3rd component) is required: ' + arn);
        }
        if (!sixth) {
            throw new Error('The `resource` component (6th component) is required: ' + arn);
        }
        let resource;
        let resourceName;
        let sep;
        let sepIndex = sixth.indexOf('/');
        if (sepIndex !== -1) {
            sep = '/';
        }
        else if (rest.length > 0) {
            sep = ':';
            sepIndex = -1;
        }
        if (sepIndex !== -1) {
            resource = sixth.substr(0, sepIndex);
            resourceName = sixth.substr(sepIndex + 1);
        }
        else {
            resource = sixth;
        }
        if (rest.length > 0) {
            if (!resourceName) {
                resourceName = '';
            }
            else {
                resourceName += ':';
            }
            resourceName += rest.join(':');
        }
        const result = { service, resource };
        if (partition) {
            result.partition = partition;
        }
        if (region) {
            result.region = region;
        }
        if (account) {
            result.account = account;
        }
        if (resourceName) {
            result.resourceName = resourceName;
        }
        if (sep) {
            result.sep = sep;
        }
        return result;
    }
    /**
     * Given a Token evaluating to ARN, parses it and returns components.
     *
     * The ARN cannot be validated, since we don't have the actual value yet
     * at the time of this function call. You will have to know the separator
     * and the type of ARN.
     *
     * The resulting `ArnComponents` object will contain tokens for the
     * subexpressions of the ARN, not string literals.
     *
     * WARNING: this function cannot properly parse the complete final
     * resourceName (path) out of ARNs that use '/' to both separate the
     * 'resource' from the 'resourceName' AND to subdivide the resourceName
     * further. For example, in S3 ARNs:
     *
     *    arn:aws:s3:::my_corporate_bucket/path/to/exampleobject.png
     *
     * After parsing the resourceName will not contain 'path/to/exampleobject.png'
     * but simply 'path'. This is a limitation because there is no slicing
     * functionality in CloudFormation templates.
     *
     * @param arn The input token that contains an ARN
     * @param sep The separator used to separate resource from resourceName
     * @param hasName Whether there is a name component in the ARN at all.
     * For example, SNS Topics ARNs have the 'resource' component contain the
     * topic name, and no 'resourceName' component.
     * @returns an ArnComponents object which allows access to the various
     * components of the ARN.
     */
    static parseToken(arn, sep = '/', hasName = true) {
        // Arn ARN looks like:
        // arn:partition:service:region:account-id:resource
        // arn:partition:service:region:account-id:resourcetype/resource
        // arn:partition:service:region:account-id:resourcetype:resource
        // We need the 'hasName' argument because {Fn::Select}ing a nonexistent field
        // throws an error.
        const components = new fn_1.FnSplit(':', arn);
        const partition = new fn_1.FnSelect(1, components).toString();
        const service = new fn_1.FnSelect(2, components).toString();
        const region = new fn_1.FnSelect(3, components).toString();
        const account = new fn_1.FnSelect(4, components).toString();
        if (sep === ':') {
            const resource = new fn_1.FnSelect(5, components).toString();
            const resourceName = hasName ? new fn_1.FnSelect(6, components).toString() : undefined;
            return { partition, service, region, account, resource, resourceName, sep };
        }
        else {
            const lastComponents = new fn_1.FnSplit(sep, new fn_1.FnSelect(5, components));
            const resource = new fn_1.FnSelect(0, lastComponents).toString();
            const resourceName = hasName ? new fn_1.FnSelect(1, lastComponents).toString() : undefined;
            return { partition, service, region, account, resource, resourceName, sep };
        }
    }
    /**
     * Return a Token that represents the resource component of the ARN
     */
    static resourceComponent(arn, sep = '/') {
        return ArnUtils.parseToken(new __1.Token(arn), sep).resource;
    }
    /**
     * Return a Token that represents the resource Name component of the ARN
     */
    static resourceNameComponent(arn, sep = '/') {
        return ArnUtils.parseToken(new __1.Token(arn), sep, true).resourceName;
    }
}
exports.ArnUtils = ArnUtils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJuLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXJuLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsMEJBQTRFO0FBQzVFLDZDQUF5RDtBQUN6RCwyQ0FBNEM7QUFDNUMsaUVBQTZEO0FBRTdEOzs7R0FHRztBQUNILE1BQWEsUUFBUTtJQUNuQjs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0ksTUFBTSxDQUFDLGNBQWMsQ0FBQyxVQUF5QjtRQUNwRCxNQUFNLFNBQVMsR0FBRyxVQUFVLENBQUMsU0FBUyxJQUFJLElBQUk7WUFDNUMsQ0FBQyxDQUFDLElBQUksZ0JBQVksRUFBRTtZQUNwQixDQUFDLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQztRQUN6QixNQUFNLE1BQU0sR0FBRyxVQUFVLENBQUMsTUFBTSxJQUFJLElBQUk7WUFDdEMsQ0FBQyxDQUFDLElBQUksYUFBUyxFQUFFO1lBQ2pCLENBQUMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDO1FBQ3RCLE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxPQUFPLElBQUksSUFBSTtZQUN4QyxDQUFDLENBQUMsSUFBSSxnQkFBWSxFQUFFO1lBQ3BCLENBQUMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDO1FBRXZCLE1BQU0sTUFBTSxHQUFHLENBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLFVBQVUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRSxVQUFVLENBQUMsUUFBUSxDQUFFLENBQUM7UUFFdkgsTUFBTSxHQUFHLEdBQUcsVUFBVSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUM7UUFDbEMsSUFBSSxHQUFHLEtBQUssR0FBRyxJQUFJLEdBQUcsS0FBSyxHQUFHLEVBQUU7WUFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDO1NBQzNEO1FBRUQsSUFBSSxVQUFVLENBQUMsWUFB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QXFPQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEF3c0FjY291bnRJZCwgQXdzUGFydGl0aW9uLCBBd3NSZWdpb24sIEZuQ29uY2F0LCBUb2tlbiB9IGZyb20gJy4uJztcbmltcG9ydCB7IEZuU2VsZWN0LCBGblNwbGl0IH0gZnJvbSAnLi4vY2xvdWRmb3JtYXRpb24vZm4nO1xuaW1wb3J0IHsgdW5yZXNvbHZlZCB9IGZyb20gJy4uL2NvcmUvdG9rZW5zJztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uVG9rZW4gfSBmcm9tICcuL2Nsb3VkZm9ybWF0aW9uLXRva2VuJztcblxuLyoqXG4gKiBBbiBBbWF6b24gUmVzb3VyY2UgTmFtZSAoQVJOKS5cbiAqIGh0dHA6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL2F3cy1hcm5zLWFuZC1uYW1lc3BhY2VzLmh0bWxcbiAqL1xuZXhwb3J0IGNsYXNzIEFyblV0aWxzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gQVJOIGZyb20gY29tcG9uZW50cy5cbiAgICpcbiAgICogSWYgYHBhcnRpdGlvbmAsIGByZWdpb25gIG9yIGBhY2NvdW50YCBhcmUgbm90IHNwZWNpZmllZCwgdGhlIHN0YWNrJ3NcbiAgICogcGFydGl0aW9uLCByZWdpb24gYW5kIGFjY291bnQgd2lsbCBiZSB1c2VkLlxuICAgKlxuICAgKiBJZiBhbnkgY29tcG9uZW50IGlzIHRoZSBlbXB0eSBzdHJpbmcsIGFuIGVtcHR5IHN0cmluZyB3aWxsIGJlIGluc2VydGVkXG4gICAqIGludG8gdGhlIGdlbmVyYXRlZCBBUk4gYXQgdGhlIGxvY2F0aW9uIHRoYXQgY29tcG9uZW50IGNvcnJlc3BvbmRzIHRvLlxuICAgKlxuICAgKiBUaGUgQVJOIHdpbGwgYmUgZm9ybWF0dGVkIGFzIGZvbGxvd3M6XG4gICAqXG4gICAqICAgYXJuOntwYXJ0aXRpb259OntzZXJ2aWNlfTp7cmVnaW9ufTp7YWNjb3VudH06e3Jlc291cmNlfXtzZXB9fXtyZXNvdXJjZS1uYW1lfVxuICAgKlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tQ29tcG9uZW50cyhjb21wb25lbnRzOiBBcm5Db21wb25lbnRzKTogc3RyaW5nIHtcbiAgICBjb25zdCBwYXJ0aXRpb24gPSBjb21wb25lbnRzLnBhcnRpdGlvbiA9PSBudWxsXG4gICAgICA/IG5ldyBBd3NQYXJ0aXRpb24oKVxuICAgICAgOiBjb21wb25lbnRzLnBhcnRpdGlvbjtcbiAgICBjb25zdCByZWdpb24gPSBjb21wb25lbnRzLnJlZ2lvbiA9PSBudWxsXG4gICAgICA/IG5ldyBBd3NSZWdpb24oKVxuICAgICAgOiBjb21wb25lbnRzLnJlZ2lvbjtcbiAgICBjb25zdCBhY2NvdW50ID0gY29tcG9uZW50cy5hY2NvdW50ID09IG51bGxcbiAgICAgID8gbmV3IEF3c0FjY291bnRJZCgpXG4gICAgICA6IGNvbXBvbmVudHMuYWNjb3VudDtcblxuICAgIGNvbnN0IHZhbHVlcyA9IFsgJ2FybicsICc6JywgcGFydGl0aW9uLCAnOicsIGNvbXBvbmVudHMuc2VydmljZSwgJzonLCByZWdpb24sICc6JywgYWNjb3VudCwgJzonLCBjb21wb25lbnRzLnJlc291cmNlIF07XG5cbiAgICBjb25zdCBzZXAgPSBjb21wb25lbnRzLnNlcCB8fCAnLyc7XG4gICAgaWYgKHNlcCAhPT0gJy8nICYmIHNlcCAhPT0gJzonKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc291cmNlUGF0aFNlcCBtYXkgb25seSBiZSBcIjpcIiBvciBcIi9cIicpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnRzLnJlc291cmNlTmFtZSAhPSBudWxsKSB7XG4gICAgICB2YWx1ZXMucHVzaChzZXApO1xuICAgICAgdmFsdWVzLnB1c2goY29tcG9uZW50cy5yZXNvdXJjZU5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRm5Db25jYXQoLi4udmFsdWVzKS50b1N0cmluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGFuIEFSTiwgcGFyc2VzIGl0IGFuZCByZXR1cm5zIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIElmIHRoZSBBUk4gaXMgYSBjb25jcmV0ZSBzdHJpbmcsIGl0IHdpbGwgYmUgcGFyc2VkIGFuZCB2YWxpZGF0ZWQuIFRoZVxuICAgKiBzZXBhcmF0b3IgKGBzZXBgKSB3aWxsIGJlIHNldCB0byAnLycgaWYgdGhlIDZ0aCBjb21wb25lbnQgaW5jbHVkZXMgYSAnLycsXG4gICAqIGluIHdoaWNoIGNhc2UsIGByZXNvdXJjZWAgd2lsbCBiZSBzZXQgdG8gdGhlIHZhbHVlIGJlZm9yZSB0aGUgJy8nIGFuZFxuICAgKiBgcmVzb3VyY2VOYW1lYCB3aWxsIGJlIHRoZSByZXN0LiBJbiBjYXNlIHRoZXJlIGlzIG5vICcvJywgYHJlc291cmNlYCB3aWxsXG4gICAqIGJlIHNldCB0byB0aGUgNnRoIGNvbXBvbmVudHMgYW5kIGByZXNvdXJjZU5hbWVgIHdpbGwgYmUgc2V0IHRvIHRoZSByZXN0XG4gICAqIG9mIHRoZSBzdHJpbmcuXG4gICAqXG4gICAqIElmIHRoZSBBUk4gaW5jbHVkZXMgdG9rZW5zIChvciBpcyBhIHRva2VuKSwgdGhlIEFSTiBjYW5ub3QgYmUgdmFsaWRhdGVkLFxuICAgKiBzaW5jZSB3ZSBkb24ndCBoYXZlIHRoZSBhY3R1YWwgdmFsdWUgeWV0IGF0IHRoZSB0aW1lIG9mIHRoaXMgZnVuY3Rpb25cbiAgICogY2FsbC4gWW91IHdpbGwgaGF2ZSB0byBrbm93IHRoZSBzZXBhcmF0b3IgYW5kIHRoZSB0eXBlIG9mIEFSTi4gVGhlXG4gICAqIHJlc3VsdGluZyBgQXJuQ29tcG9uZW50c2Agb2JqZWN0IHdpbGwgY29udGFpbiB0b2tlbnMgZm9yIHRoZVxuICAgKiBzdWJleHByZXNzaW9ucyBvZiB0aGUgQVJOLCBub3Qgc3RyaW5nIGxpdGVyYWxzLiBJbiB0aGlzIGNhc2UgdGhpc1xuICAgKiBmdW5jdGlvbiBjYW5ub3QgcHJvcGVybHkgcGFyc2UgdGhlIGNvbXBsZXRlIGZpbmFsIHJlc291cmNlTmFtZSAocGF0aCkgb3V0XG4gICAqIG9mIEFSTnMgdGhhdCB1c2UgJy8nIHRvIGJvdGggc2VwYXJhdGUgdGhlICdyZXNvdXJjZScgZnJvbSB0aGVcbiAgICogJ3Jlc291cmNlTmFtZScgQU5EIHRvIHN1YmRpdmlkZSB0aGUgcmVzb3VyY2VOYW1lIGZ1cnRoZXIuIEZvciBleGFtcGxlLCBpblxuICAgKiBTMyBBUk5zOlxuICAgKlxuICAgKiAgICBhcm46YXdzOnMzOjo6bXlfY29ycG9yYXRlX2J1Y2tldC9wYXRoL3RvL2V4YW1wbGVvYmplY3QucG5nXG4gICAqXG4gICAqIEFmdGVyIHBhcnNpbmcgdGhlIHJlc291cmNlTmFtZSB3aWxsIG5vdCBjb250YWluXG4gICAqICdwYXRoL3RvL2V4YW1wbGVvYmplY3QucG5nJyBidXQgc2ltcGx5ICdwYXRoJy4gVGhpcyBpcyBhIGxpbWl0YXRpb25cbiAgICogYmVjYXVzZSB0aGVyZSBpcyBubyBzbGljaW5nIGZ1bmN0aW9uYWxpdHkgaW4gQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0gc2VwIFRoZSBzZXBhcmF0b3IgdXNlZCB0byBzZXBhcmF0ZSByZXNvdXJjZSBmcm9tIHJlc291cmNlTmFtZVxuICAgKiBAcGFyYW0gaGFzTmFtZSBXaGV0aGVyIHRoZXJlIGlzIGEgbmFtZSBjb21wb25lbnQgaW4gdGhlIEFSTiBhdCBhbGwuIEZvclxuICAgKiBleGFtcGxlLCBTTlMgVG9waWNzIEFSTnMgaGF2ZSB0aGUgJ3Jlc291cmNlJyBjb21wb25lbnQgY29udGFpbiB0aGUgdG9waWNcbiAgICogbmFtZSwgYW5kIG5vICdyZXNvdXJjZU5hbWUnIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHJldHVybnMgYW4gQXJuQ29tcG9uZW50cyBvYmplY3Qgd2hpY2ggYWxsb3dzIGFjY2VzcyB0byB0aGUgdmFyaW91c1xuICAgKiBjb21wb25lbnRzIG9mIHRoZSBBUk4uXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIEFybkNvbXBvbmVudHMgb2JqZWN0IHdoaWNoIGFsbG93cyBhY2Nlc3MgdG8gdGhlIHZhcmlvdXNcbiAgICogICAgICBjb21wb25lbnRzIG9mIHRoZSBBUk4uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHBhcnNlKGFybjogc3RyaW5nLCBzZXBJZlRva2VuOiBzdHJpbmcgPSAnLycsIGhhc05hbWU6IGJvb2xlYW4gPSB0cnVlKTogQXJuQ29tcG9uZW50cyB7XG4gICAgaWYgKHVucmVzb2x2ZWQoYXJuKSkge1xuICAgICAgcmV0dXJuIEFyblV0aWxzLnBhcnNlVG9rZW4obmV3IENsb3VkRm9ybWF0aW9uVG9rZW4oYXJuKSwgc2VwSWZUb2tlbiwgaGFzTmFtZSk7XG4gICAgfVxuXG4gICAgY29uc3QgY29tcG9uZW50cyA9IGFybi5zcGxpdCgnOicpIGFzIEFycmF5PHN0cmluZyB8IHVuZGVmaW5lZD47XG5cbiAgICBpZiAoY29tcG9uZW50cy5sZW5ndGggPCA2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FSTnMgbXVzdCBoYXZlIGF0IGxlYXN0IDYgY29tcG9uZW50czogJyArIGFybik7XG4gICAgfVxuXG4gICAgY29uc3QgWyBhcm5QcmVmaXgsIHBhcnRpdGlvbiwgc2VydmljZSwgcmVnaW9uLCBhY2NvdW50LCBzaXh0aCwgLi4ucmVzdCBdID0gY29tcG9uZW50cztcblxuICAgIGlmIChhcm5QcmVmaXggIT09ICdhcm4nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FSTnMgbXVzdCBzdGFydCB3aXRoIFwiYXJuOlwiOiAnICsgYXJuKTtcbiAgICB9XG5cbiAgICBpZiAoIXNlcnZpY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGBzZXJ2aWNlYCBjb21wb25lbnQgKDNyZCBjb21wb25lbnQpIGlzIHJlcXVpcmVkOiAnICsgYXJuKTtcbiAgICB9XG5cbiAgICBpZiAoIXNpeHRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgcmVzb3VyY2VgIGNvbXBvbmVudCAoNnRoIGNvbXBvbmVudCkgaXMgcmVxdWlyZWQ6ICcgKyBhcm4pO1xuICAgIH1cblxuICAgIGxldCByZXNvdXJjZTogc3RyaW5nO1xuICAgIGxldCByZXNvdXJjZU5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBsZXQgc2VwOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgICBsZXQgc2VwSW5kZXggPSBzaXh0aC5pbmRleE9mKCcvJyk7XG4gICAgaWYgKHNlcEluZGV4ICE9PSAtMSkge1xuICAgICAgc2VwID0gJy8nO1xuICAgIH0gZWxzZSBpZiAocmVzdC5sZW5ndGggPiAwKSB7XG4gICAgICBzZXAgPSAnOic7XG4gICAgICBzZXBJbmRleCA9IC0xO1xuICAgIH1cblxuICAgIGlmIChzZXBJbmRleCAhPT0gLTEpIHtcbiAgICAgIHJlc291cmNlID0gc2l4dGguc3Vic3RyKDAsIHNlcEluZGV4KTtcbiAgICAgIHJlc291cmNlTmFtZSA9IHNpeHRoLnN1YnN0cihzZXBJbmRleCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvdXJjZSA9IHNpeHRoO1xuICAgIH1cblxuICAgIGlmIChyZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICghcmVzb3VyY2VOYW1lKSB7XG4gICAgICAgIHJlc291cmNlTmFtZSA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb3VyY2VOYW1lICs9ICc6JztcbiAgICAgIH1cblxuICAgICAgcmVzb3VyY2VOYW1lICs9IHJlc3Quam9pbignOicpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdDogQXJuQ29tcG9uZW50cyA9IHsgc2VydmljZSwgcmVzb3VyY2UgfTtcbiAgICBpZiAocGFydGl0aW9uKSB7XG4gICAgICByZXN1bHQucGFydGl0aW9uID0gcGFydGl0aW9uO1xuICAgIH1cblxuICAgIGlmIChyZWdpb24pIHtcbiAgICAgIHJlc3VsdC5yZWdpb24gPSByZWdpb247XG4gICAgfVxuXG4gICAgaWYgKGFjY291bnQpIHtcbiAgICAgIHJlc3VsdC5hY2NvdW50ID0gYWNjb3VudDtcbiAgICB9XG5cbiAgICBpZiAocmVzb3VyY2VOYW1lKSB7XG4gICAgICByZXN1bHQucmVzb3VyY2VOYW1lID0gcmVzb3VyY2VOYW1lO1xuICAgIH1cblxuICAgIGlmIChzZXApIHtcbiAgICAgIHJlc3VsdC5zZXAgPSBzZXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIFRva2VuIGV2YWx1YXRpbmcgdG8gQVJOLCBwYXJzZXMgaXQgYW5kIHJldHVybnMgY29tcG9uZW50cy5cbiAgICpcbiAgICogVGhlIEFSTiBjYW5ub3QgYmUgdmFsaWRhdGVkLCBzaW5jZSB3ZSBkb24ndCBoYXZlIHRoZSBhY3R1YWwgdmFsdWUgeWV0XG4gICAqIGF0IHRoZSB0aW1lIG9mIHRoaXMgZnVuY3Rpb24gY2FsbC4gWW91IHdpbGwgaGF2ZSB0byBrbm93IHRoZSBzZXBhcmF0b3JcbiAgICogYW5kIHRoZSB0eXBlIG9mIEFSTi5cbiAgICpcbiAgICogVGhlIHJlc3VsdGluZyBgQXJuQ29tcG9uZW50c2Agb2JqZWN0IHdpbGwgY29udGFpbiB0b2tlbnMgZm9yIHRoZVxuICAgKiBzdWJleHByZXNzaW9ucyBvZiB0aGUgQVJOLCBub3Qgc3RyaW5nIGxpdGVyYWxzLlxuICAgKlxuICAgKiBXQVJOSU5HOiB0aGlzIGZ1bmN0aW9uIGNhbm5vdCBwcm9wZXJseSBwYXJzZSB0aGUgY29tcGxldGUgZmluYWxcbiAgICogcmVzb3VyY2VOYW1lIChwYXRoKSBvdXQgb2YgQVJOcyB0aGF0IHVzZSAnLycgdG8gYm90aCBzZXBhcmF0ZSB0aGVcbiAgICogJ3Jlc291cmNlJyBmcm9tIHRoZSAncmVzb3VyY2VOYW1lJyBBTkQgdG8gc3ViZGl2aWRlIHRoZSByZXNvdXJjZU5hbWVcbiAgICogZnVydGhlci4gRm9yIGV4YW1wbGUsIGluIFMzIEFSTnM6XG4gICAqXG4gICAqICAgIGFybjphd3M6czM6OjpteV9jb3Jwb3JhdGVfYnVja2V0L3BhdGgvdG8vZXhhbXBsZW9iamVjdC5wbmdcbiAgICpcbiAgICogQWZ0ZXIgcGFyc2luZyB0aGUgcmVzb3VyY2VOYW1lIHdpbGwgbm90IGNvbnRhaW4gJ3BhdGgvdG8vZXhhbXBsZW9iamVjdC5wbmcnXG4gICAqIGJ1dCBzaW1wbHkgJ3BhdGgnLiBUaGlzIGlzIGEgbGltaXRhdGlvbiBiZWNhdXNlIHRoZXJlIGlzIG5vIHNsaWNpbmdcbiAgICogZnVuY3Rpb25hbGl0eSBpbiBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSBhcm4gVGhlIGlucHV0IHRva2VuIHRoYXQgY29udGFpbnMgYW4gQVJOXG4gICAqIEBwYXJhbSBzZXAgVGhlIHNlcGFyYXRvciB1c2VkIHRvIHNlcGFyYXRlIHJlc291cmNlIGZyb20gcmVzb3VyY2VOYW1lXG4gICAqIEBwYXJhbSBoYXNOYW1lIFdoZXRoZXIgdGhlcmUgaXMgYSBuYW1lIGNvbXBvbmVudCBpbiB0aGUgQVJOIGF0IGFsbC5cbiAgICogRm9yIGV4YW1wbGUsIFNOUyBUb3BpY3MgQVJOcyBoYXZlIHRoZSAncmVzb3VyY2UnIGNvbXBvbmVudCBjb250YWluIHRoZVxuICAgKiB0b3BpYyBuYW1lLCBhbmQgbm8gJ3Jlc291cmNlTmFtZScgY29tcG9uZW50LlxuICAgKiBAcmV0dXJucyBhbiBBcm5Db21wb25lbnRzIG9iamVjdCB3aGljaCBhbGxvd3MgYWNjZXNzIHRvIHRoZSB2YXJpb3VzXG4gICAqIGNvbXBvbmVudHMgb2YgdGhlIEFSTi5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcGFyc2VUb2tlbihhcm46IFRva2VuLCBzZXA6IHN0cmluZyA9ICcvJywgaGFzTmFtZTogYm9vbGVhbiA9IHRydWUpOiBBcm5Db21wb25lbnRzIHtcbiAgICAvLyBBcm4gQVJOIGxvb2tzIGxpa2U6XG4gICAgLy8gYXJuOnBhcnRpdGlvbjpzZXJ2aWNlOnJlZ2lvbjphY2NvdW50LWlkOnJlc291cmNlXG4gICAgLy8gYXJuOnBhcnRpdGlvbjpzZXJ2aWNlOnJlZ2lvbjphY2NvdW50LWlkOnJlc291cmNldHlwZS9yZXNvdXJjZVxuICAgIC8vIGFybjpwYXJ0aXRpb246c2VydmljZTpyZWdpb246YWNjb3VudC1pZDpyZXNvdXJjZXR5cGU6cmVzb3VyY2VcblxuICAgIC8vIFdlIG5lZWQgdGhlICdoYXNOYW1lJyBhcmd1bWVudCBiZWNhdXNlIHtGbjo6U2VsZWN0fWluZyBhIG5vbmV4aXN0ZW50IGZpZWxkXG4gICAgLy8gdGhyb3dzIGFuIGVycm9yLlxuXG4gICAgY29uc3QgY29tcG9uZW50cyA9IG5ldyBGblNwbGl0KCc6JywgYXJuKTtcblxuICAgIGNvbnN0IHBhcnRpdGlvbiA9IG5ldyBGblNlbGVjdCgxLCBjb21wb25lbnRzKS50b1N0cmluZygpO1xuICAgIGNvbnN0IHNlcnZpY2UgPSBuZXcgRm5TZWxlY3QoMiwgY29tcG9uZW50cykudG9TdHJpbmcoKTtcbiAgICBjb25zdCByZWdpb24gPSBuZXcgRm5TZWxlY3QoMywgY29tcG9uZW50cykudG9TdHJpbmcoKTtcbiAgICBjb25zdCBhY2NvdW50ID0gbmV3IEZuU2VsZWN0KDQsIGNvbXBvbmVudHMpLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAoc2VwID09PSAnOicpIHtcbiAgICAgIGNvbnN0IHJlc291cmNlID0gbmV3IEZuU2VsZWN0KDUsIGNvbXBvbmVudHMpLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCByZXNvdXJjZU5hbWUgPSBoYXNOYW1lID8gbmV3IEZuU2VsZWN0KDYsIGNvbXBvbmVudHMpLnRvU3RyaW5nKCkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybiB7IHBhcnRpdGlvbiwgc2VydmljZSwgcmVnaW9uLCBhY2NvdW50LCByZXNvdXJjZSwgcmVzb3VyY2VOYW1lLCBzZXAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGFzdENvbXBvbmVudHMgPSBuZXcgRm5TcGxpdChzZXAsIG5ldyBGblNlbGVjdCg1LCBjb21wb25lbnRzKSk7XG5cbiAgICAgIGNvbnN0IHJlc291cmNlID0gbmV3IEZuU2VsZWN0KDAsIGxhc3RDb21wb25lbnRzKS50b1N0cmluZygpO1xuICAgICAgY29uc3QgcmVzb3VyY2VOYW1lID0gaGFzTmFtZSA/IG5ldyBGblNlbGVjdCgxLCBsYXN0Q29tcG9uZW50cykudG9TdHJpbmcoKSA6IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIHsgcGFydGl0aW9uLCBzZXJ2aWNlLCByZWdpb24sIGFjY291bnQsIHJlc291cmNlLCByZXNvdXJjZU5hbWUsIHNlcCB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBUb2tlbiB0aGF0IHJlcHJlc2VudHMgdGhlIHJlc291cmNlIGNvbXBvbmVudCBvZiB0aGUgQVJOXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlc291cmNlQ29tcG9uZW50KGFybjogc3RyaW5nLCBzZXA6IHN0cmluZyA9ICcvJyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIEFyblV0aWxzLnBhcnNlVG9rZW4obmV3IFRva2VuKGFybiksIHNlcCkucmVzb3VyY2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgVG9rZW4gdGhhdCByZXByZXNlbnRzIHRoZSByZXNvdXJjZSBOYW1lIGNvbXBvbmVudCBvZiB0aGUgQVJOXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlc291cmNlTmFtZUNvbXBvbmVudChhcm46IHN0cmluZywgc2VwOiBzdHJpbmcgPSAnLycpOiBzdHJpbmcge1xuICAgIHJldHVybiBBcm5VdGlscy5wYXJzZVRva2VuKG5ldyBUb2tlbihhcm4pLCBzZXAsIHRydWUpLnJlc291cmNlTmFtZSE7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcm5Db21wb25lbnRzIHtcbiAgLyoqXG4gICAqIFRoZSBwYXJ0aXRpb24gdGhhdCB0aGUgcmVzb3VyY2UgaXMgaW4uIEZvciBzdGFuZGFyZCBBV1MgcmVnaW9ucywgdGhlXG4gICAqIHBhcnRpdGlvbiBpcyBhd3MuIElmIHlvdSBoYXZlIHJlc291cmNlcyBpbiBvdGhlciBwYXJ0aXRpb25zLCB0aGVcbiAgICogcGFydGl0aW9uIGlzIGF3cy1wYXJ0aXRpb25uYW1lLiBGb3IgZXhhbXBsZSwgdGhlIHBhcnRpdGlvbiBmb3IgcmVzb3VyY2VzXG4gICAqIGluIHRoZSBDaGluYSAoQmVpamluZykgcmVnaW9uIGlzIGF3cy1jbi5cbiAgICpcbiAgICogQGRlZmF1bHQgVGhlIEFXUyBwYXJ0aXRpb24gdGhlIHN0YWNrIGlzIGRlcGxveWVkIHRvLlxuICAgKi9cbiAgcGFydGl0aW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgc2VydmljZSBuYW1lc3BhY2UgdGhhdCBpZGVudGlmaWVzIHRoZSBBV1MgcHJvZHVjdCAoZm9yIGV4YW1wbGUsXG4gICAqICdzMycsICdpYW0nLCAnY29kZXBpcGxpbmUnKS5cbiAgICovXG4gIHNlcnZpY2U6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJlZ2lvbiB0aGUgcmVzb3VyY2UgcmVzaWRlcyBpbi4gTm90ZSB0aGF0IHRoZSBBUk5zIGZvciBzb21lIHJlc291cmNlc1xuICAgKiBkbyBub3QgcmVxdWlyZSBhIHJlZ2lvbiwgc28gdGhpcyBjb21wb25lbnQgbWlnaHQgYmUgb21pdHRlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgVGhlIHJlZ2lvbiB0aGUgc3RhY2sgaXMgZGVwbG95ZWQgdG8uXG4gICAqL1xuICByZWdpb24/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgQVdTIGFjY291bnQgdGhhdCBvd25zIHRoZSByZXNvdXJjZSwgd2l0aG91dCB0aGUgaHlwaGVucy5cbiAgICogRm9yIGV4YW1wbGUsIDEyMzQ1Njc4OTAxMi4gTm90ZSB0aGF0IHRoZSBBUk5zIGZvciBzb21lIHJlc291cmNlcyBkb24ndFxuICAgKiByZXF1aXJlIGFuIGFjY291bnQgbnVtYmVyLCBzbyB0aGlzIGNvbXBvbmVudCBtaWdodCBiZSBvbWl0dGVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBUaGUgYWNjb3VudCB0aGUgc3RhY2sgaXMgZGVwbG95ZWQgdG8uXG4gICAqL1xuICBhY2NvdW50Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZXNvdXJjZSB0eXBlIChlLmcuIFwidGFibGVcIiwgXCJhdXRvU2NhbGluZ0dyb3VwXCIsIFwiY2VydGlmaWNhdGVcIikuXG4gICAqIEZvciBzb21lIHJlc291cmNlIHR5cGVzLCBlLmcuIFMzIGJ1Y2tldHMsIHRoaXMgZmllbGQgZGVmaW5lcyB0aGUgYnVja2V0IG5hbWUuXG4gICAqL1xuICByZXNvdXJjZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTZXBhcmF0b3IgYmV0d2VlbiByZXNvdXJjZSB0eXBlIGFuZCB0aGUgcmVzb3VyY2UuXG4gICAqXG4gICAqIENhbiBiZSBlaXRoZXIgJy8nIG9yICc6Jy4gV2lsbCBvbmx5IGJlIHVzZWQgaWYgcGF0aCBpcyBkZWZpbmVkLlxuICAgKiBAZGVmYXVsdCAnLydcbiAgICovXG4gIHNlcD86IHN0cmluZztcblxuICAvKipcbiAgICogUmVzb3VyY2UgbmFtZSBvciBwYXRoIHdpdGhpbiB0aGUgcmVzb3VyY2UgKGkuZS4gUzMgYnVja2V0IG9iamVjdCBrZXkpIG9yXG4gICAqIGEgd2lsZGNhcmQgc3VjaCBhcyBgYFwiKlwiYGAuIFRoaXMgaXMgc2VydmljZS1kZXBlbmRlbnQuXG4gICAqL1xuICByZXNvdXJjZU5hbWU/OiBzdHJpbmc7XG59XG4iXX0=