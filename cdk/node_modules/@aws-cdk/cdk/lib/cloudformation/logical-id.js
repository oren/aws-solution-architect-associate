"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const uniqueid_1 = require("../util/uniqueid");
const PATH_SEP = '/';
/**
 * Renders a hashed ID for a resource.
 *
 * In order to make sure logical IDs are unique and stable, we hash the resource
 * construct tree path (i.e. toplevel/secondlevel/.../myresource) and add it as
 * a suffix to the path components joined without a separator (CloudFormation
 * IDs only allow alphanumeric characters).
 *
 * The result will be:
 *
 *   <path.join('')><md5(path.join('/')>
 *     "human"      "hash"
 *
 * If the "human" part of the ID exceeds 240 characters, we simply trim it so
 * the total ID doesn't exceed CloudFormation's 255 character limit.
 *
 * We only take 8 characters from the md5 hash (0.000005 chance of collision).
 *
 * Special cases:
 *
 * - If the path only contains a single component (i.e. it's a top-level
 *   resource), we won't add the hash to it. The hash is not needed for
 *   disamiguation and also, it allows for a more straightforward migration an
 *   existing CloudFormation template to a CDK stack without logical ID changes
 *   (or renames).
 * - For aesthetic reasons, if the last components of the path are the same
 *   (i.e. `L1/L2/Pipeline/Pipeline`), they will be de-duplicated to make the
 *   resulting human portion of the ID more pleasing: `L1L2Pipeline<HASH>`
 *   instead of `L1L2PipelinePipeline<HASH>`
 * - If a component is named "Default" it will be omitted from the path. This
 *   allows refactoring higher level abstractions around constructs without affecting
 *   the IDs of already deployed resources.
 * - If a component is named "Resource" it will be omitted from the user-visible
 *   path, but included in the hash. This reduces visual noise in the human readable
 *   part of the identifier.
 */
class HashedAddressingScheme {
    allocateAddress(addressComponents) {
        return uniqueid_1.makeUniqueId(addressComponents);
    }
}
exports.HashedAddressingScheme = HashedAddressingScheme;
/**
 * Class that keeps track of the logical IDs that are assigned to resources
 *
 * Supports renaming the generated IDs.
 */
class LogicalIDs {
    constructor(namingScheme) {
        this.namingScheme = namingScheme;
        /**
         * The rename table (old to new)
         */
        this.renames = {};
        /**
         * All assigned names (new to old, may be identical)
         *
         * This is used to ensure that:
         *
         * - No 2 resources end up with the same final logical ID, unless they were the same to begin with.
         * - All renames have been used at the end of renaming.
         */
        this.reverse = {};
    }
    /**
     * Rename a logical ID from an old ID to a new ID
     */
    renameLogical(oldId, newId) {
        if (oldId in this.renames) {
            throw new Error(`A rename has already been registered for '${oldId}'`);
        }
        this.renames[oldId] = newId;
    }
    /**
     * Return the logical ID for the given stack element
     */
    getLogicalId(stackElement) {
        const path = stackElement.stackPath.split(PATH_SEP);
        const generatedId = this.namingScheme.allocateAddress(path);
        const finalId = this.applyRename(generatedId);
        validateLogicalId(finalId);
        return finalId;
    }
    /**
     * Throw an error if not all renames have been used
     *
     * This is to assure that users didn't make typoes when registering renames.
     */
    assertAllRenamesApplied() {
        const keys = new Set();
        Object.keys(this.renames).forEach(keys.add.bind(keys));
        Object.keys(this.reverse).map(newId => {
            keys.delete(this.reverse[newId]);
        });
        if (keys.size !== 0) {
            const unusedRenames = Array.from(keys.values());
            throw new Error(`The following Logical IDs were attempted to be renamed, but not found: ${unusedRenames.join(', ')}`);
        }
    }
    /**
     * Return the renamed version of an ID, if applicable
     */
    applyRename(oldId) {
        let newId = oldId;
        if (oldId in this.renames) {
            newId = this.renames[oldId];
        }
        // If this newId has already been used, it must have been with the same oldId
        if (newId in this.reverse && this.reverse[newId] !== oldId) {
            // tslint:disable-next-line:max-line-length
            throw new Error(`Two objects have been assigned the same Logical ID: '${this.reverse[newId]}' and '${oldId}' are now both named '${newId}'.`);
        }
        this.reverse[newId] = oldId;
        return newId;
    }
}
exports.LogicalIDs = LogicalIDs;
const VALID_LOGICALID_REGEX = /^[A-Za-z][A-Za-z0-9]{1,254}$/;
/**
 * Validate logical ID is valid for CloudFormation
 */
function validateLogicalId(logicalId) {
    if (!VALID_LOGICALID_REGEX.test(logicalId)) {
        throw new Error(`Logical ID must adhere to the regular expression: ${VALID_LOGICALID_REGEX.toString()}, got '${logicalId}'`);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9naWNhbC1pZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxvZ2ljYWwtaWQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwrQ0FBZ0Q7QUFHaEQsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDO0FBWXJCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW1DRztBQUNILE1BQWEsc0JBQXNCO0lBQzFCLGVBQWUsQ0FBQyxpQkFBMkI7UUFDaEQsT0FBTyx1QkFBWSxDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFDekMsQ0FBQztDQUNGO0FBSkQsd0RBSUM7QUFFRDs7OztHQUlHO0FBQ0gsTUFBYSxVQUFVO0lBZ0JyQixZQUE2QixZQUErQjtRQUEvQixpQkFBWSxHQUFaLFlBQVksQ0FBbUI7UUFmNUQ7O1dBRUc7UUFDYyxZQUFPLEdBQTRCLEVBQUUsQ0FBQztRQUV2RDs7Ozs7OztXQU9HO1FBQ2MsWUFBTyxHQUEyQixFQUFFLENBQUM7SUFHdEQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksYUFBYSxDQUFDLEtBQWEsRUFBRSxLQUFhO1FBQy9DLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDekIsTUFBTSxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsS0FBSyxHQUFHLENBQUMsQ0FBQztTQUN4RTtRQUNELElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBQzlCLENBQUM7SUFFRDs7T0FFRztJQUNJLFlBQVksQ0FBQyxZQUEwQjtRQUM1QyxNQUFNLElBQUksR0FBRyxZQUFZLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUVwRCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1RCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzlDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzNCLE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksdUJBQXVCO1FBQzVCLE1BQU0sSUFBSSxHQUFHLElBQUksR0FBRyxFQUFVLENBQUM7UUFDL0IsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFFdkQsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3BDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ25DLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRTtZQUNuQixNQUFNLGFBQWEsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1lBQ2hELE1BQU0sSUFBSSxLQUFLLENBQUMsMEVBQTBFLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3ZIO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ssV0FBVyxDQUFDLEtBQWE7UUFDL0IsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ2xCLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDekIsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDN0I7UUFFRCw2RUFBNkU7UUFDN0UsSUFBSSxLQUFLLElBQUksSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLEtBQUssRUFBRTtZQUMxRCwyQ0FBMkM7WUFDM0MsTUFBTSxJQUFJLEtBQUssQ0FBQyx3REFBd0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsVUFBVSxLQUFLLHlCQUF5QixLQUFLLElBQUksQ0FBQyxDQUFDO1NBQy9JO1FBQ0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUM7UUFFNUIsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0NBQ0Y7QUE5RUQsZ0NBOEVDO0FBRUQsTUFBTSxxQkFBcUIsR0FBRyw4QkFBOEIsQ0FBQztBQUU3RDs7R0FFRztBQUNILFNBQVMsaUJBQWlCLENBQUMsU0FBaUI7SUFDMUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUMxQyxNQUFNLElBQUksS0FBSyxDQUFDLHFEQUFxRCxxQkFBcUIsQ0FBQyxRQUFRLEVBQUUsVUFBVSxTQUFTLEdBQUcsQ0FBQyxDQUFDO0tBQzlIO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1ha2VVbmlxdWVJZCB9IGZyb20gJy4uL3V0aWwvdW5pcXVlaWQnO1xuaW1wb3J0IHsgU3RhY2tFbGVtZW50IH0gZnJvbSAnLi9zdGFjayc7XG5cbmNvbnN0IFBBVEhfU0VQID0gJy8nO1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgY2xhc3NlcyB0aGF0IGltcGxlbWVudGF0aW9uIGxvZ2ljYWwgSUQgYXNzaWdubWVudCBzdHJhdGVnaWVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUFkZHJlc3NpbmdTY2hlbWUge1xuICAvKipcbiAgICogUmV0dXJuIHRoZSBsb2dpY2FsIElEIGZvciB0aGUgZ2l2ZW4gbGlzdCBvZiBDb25zdHJ1Y3QgbmFtZXMgb24gdGhlIHBhdGguXG4gICAqL1xuICBhbGxvY2F0ZUFkZHJlc3MoYWRkcmVzc0NvbXBvbmVudHM6IHN0cmluZ1tdKTogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgYSBoYXNoZWQgSUQgZm9yIGEgcmVzb3VyY2UuXG4gKlxuICogSW4gb3JkZXIgdG8gbWFrZSBzdXJlIGxvZ2ljYWwgSURzIGFyZSB1bmlxdWUgYW5kIHN0YWJsZSwgd2UgaGFzaCB0aGUgcmVzb3VyY2VcbiAqIGNvbnN0cnVjdCB0cmVlIHBhdGggKGkuZS4gdG9wbGV2ZWwvc2Vjb25kbGV2ZWwvLi4uL215cmVzb3VyY2UpIGFuZCBhZGQgaXQgYXNcbiAqIGEgc3VmZml4IHRvIHRoZSBwYXRoIGNvbXBvbmVudHMgam9pbmVkIHdpdGhvdXQgYSBzZXBhcmF0b3IgKENsb3VkRm9ybWF0aW9uXG4gKiBJRHMgb25seSBhbGxvdyBhbHBoYW51bWVyaWMgY2hhcmFjdGVycykuXG4gKlxuICogVGhlIHJlc3VsdCB3aWxsIGJlOlxuICpcbiAqICAgPHBhdGguam9pbignJyk+PG1kNShwYXRoLmpvaW4oJy8nKT5cbiAqICAgICBcImh1bWFuXCIgICAgICBcImhhc2hcIlxuICpcbiAqIElmIHRoZSBcImh1bWFuXCIgcGFydCBvZiB0aGUgSUQgZXhjZWVkcyAyNDAgY2hhcmFjdGVycywgd2Ugc2ltcGx5IHRyaW0gaXQgc29cbiAqIHRoZSB0b3RhbCBJRCBkb2Vzbid0IGV4Y2VlZCBDbG91ZEZvcm1hdGlvbidzIDI1NSBjaGFyYWN0ZXIgbGltaXQuXG4gKlxuICogV2Ugb25seSB0YWtlIDggY2hhcmFjdGVycyBmcm9tIHRoZSBtZDUgaGFzaCAoMC4wMDAwMDUgY2hhbmNlIG9mIGNvbGxpc2lvbikuXG4gKlxuICogU3BlY2lhbCBjYXNlczpcbiAqXG4gKiAtIElmIHRoZSBwYXRoIG9ubHkgY29udGFpbnMgYSBzaW5nbGUgY29tcG9uZW50IChpLmUuIGl0J3MgYSB0b3AtbGV2ZWxcbiAqICAgcmVzb3VyY2UpLCB3ZSB3b24ndCBhZGQgdGhlIGhhc2ggdG8gaXQuIFRoZSBoYXNoIGlzIG5vdCBuZWVkZWQgZm9yXG4gKiAgIGRpc2FtaWd1YXRpb24gYW5kIGFsc28sIGl0IGFsbG93cyBmb3IgYSBtb3JlIHN0cmFpZ2h0Zm9yd2FyZCBtaWdyYXRpb24gYW5cbiAqICAgZXhpc3RpbmcgQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGUgdG8gYSBDREsgc3RhY2sgd2l0aG91dCBsb2dpY2FsIElEIGNoYW5nZXNcbiAqICAgKG9yIHJlbmFtZXMpLlxuICogLSBGb3IgYWVzdGhldGljIHJlYXNvbnMsIGlmIHRoZSBsYXN0IGNvbXBvbmVudHMgb2YgdGhlIHBhdGggYXJlIHRoZSBzYW1lXG4gKiAgIChpLmUuIGBMMS9MMi9QaXBlbGluZS9QaXBlbGluZWApLCB0aGV5IHdpbGwgYmUgZGUtZHVwbGljYXRlZCB0byBtYWtlIHRoZVxuICogICByZXN1bHRpbmcgaHVtYW4gcG9ydGlvbiBvZiB0aGUgSUQgbW9yZSBwbGVhc2luZzogYEwxTDJQaXBlbGluZTxIQVNIPmBcbiAqICAgaW5zdGVhZCBvZiBgTDFMMlBpcGVsaW5lUGlwZWxpbmU8SEFTSD5gXG4gKiAtIElmIGEgY29tcG9uZW50IGlzIG5hbWVkIFwiRGVmYXVsdFwiIGl0IHdpbGwgYmUgb21pdHRlZCBmcm9tIHRoZSBwYXRoLiBUaGlzXG4gKiAgIGFsbG93cyByZWZhY3RvcmluZyBoaWdoZXIgbGV2ZWwgYWJzdHJhY3Rpb25zIGFyb3VuZCBjb25zdHJ1Y3RzIHdpdGhvdXQgYWZmZWN0aW5nXG4gKiAgIHRoZSBJRHMgb2YgYWxyZWFkeSBkZXBsb3llZCByZXNvdXJjZXMuXG4gKiAtIElmIGEgY29tcG9uZW50IGlzIG5hbWVkIFwiUmVzb3VyY2VcIiBpdCB3aWxsIGJlIG9taXR0ZWQgZnJvbSB0aGUgdXNlci12aXNpYmxlXG4gKiAgIHBhdGgsIGJ1dCBpbmNsdWRlZCBpbiB0aGUgaGFzaC4gVGhpcyByZWR1Y2VzIHZpc3VhbCBub2lzZSBpbiB0aGUgaHVtYW4gcmVhZGFibGVcbiAqICAgcGFydCBvZiB0aGUgaWRlbnRpZmllci5cbiAqL1xuZXhwb3J0IGNsYXNzIEhhc2hlZEFkZHJlc3NpbmdTY2hlbWUgaW1wbGVtZW50cyBJQWRkcmVzc2luZ1NjaGVtZSB7XG4gIHB1YmxpYyBhbGxvY2F0ZUFkZHJlc3MoYWRkcmVzc0NvbXBvbmVudHM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbWFrZVVuaXF1ZUlkKGFkZHJlc3NDb21wb25lbnRzKTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHRoYXQga2VlcHMgdHJhY2sgb2YgdGhlIGxvZ2ljYWwgSURzIHRoYXQgYXJlIGFzc2lnbmVkIHRvIHJlc291cmNlc1xuICpcbiAqIFN1cHBvcnRzIHJlbmFtaW5nIHRoZSBnZW5lcmF0ZWQgSURzLlxuICovXG5leHBvcnQgY2xhc3MgTG9naWNhbElEcyB7XG4gIC8qKlxuICAgKiBUaGUgcmVuYW1lIHRhYmxlIChvbGQgdG8gbmV3KVxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSByZW5hbWVzOiB7W29sZDogc3RyaW5nXTogc3RyaW5nfSA9IHt9O1xuXG4gIC8qKlxuICAgKiBBbGwgYXNzaWduZWQgbmFtZXMgKG5ldyB0byBvbGQsIG1heSBiZSBpZGVudGljYWwpXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhhdDpcbiAgICpcbiAgICogLSBObyAyIHJlc291cmNlcyBlbmQgdXAgd2l0aCB0aGUgc2FtZSBmaW5hbCBsb2dpY2FsIElELCB1bmxlc3MgdGhleSB3ZXJlIHRoZSBzYW1lIHRvIGJlZ2luIHdpdGguXG4gICAqIC0gQWxsIHJlbmFtZXMgaGF2ZSBiZWVuIHVzZWQgYXQgdGhlIGVuZCBvZiByZW5hbWluZy5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgcmV2ZXJzZToge1tpZDogc3RyaW5nXTogc3RyaW5nfSA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgbmFtaW5nU2NoZW1lOiBJQWRkcmVzc2luZ1NjaGVtZSkge1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmFtZSBhIGxvZ2ljYWwgSUQgZnJvbSBhbiBvbGQgSUQgdG8gYSBuZXcgSURcbiAgICovXG4gIHB1YmxpYyByZW5hbWVMb2dpY2FsKG9sZElkOiBzdHJpbmcsIG5ld0lkOiBzdHJpbmcpIHtcbiAgICBpZiAob2xkSWQgaW4gdGhpcy5yZW5hbWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgcmVuYW1lIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBmb3IgJyR7b2xkSWR9J2ApO1xuICAgIH1cbiAgICB0aGlzLnJlbmFtZXNbb2xkSWRdID0gbmV3SWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsb2dpY2FsIElEIGZvciB0aGUgZ2l2ZW4gc3RhY2sgZWxlbWVudFxuICAgKi9cbiAgcHVibGljIGdldExvZ2ljYWxJZChzdGFja0VsZW1lbnQ6IFN0YWNrRWxlbWVudCk6IHN0cmluZyB7XG4gICAgY29uc3QgcGF0aCA9IHN0YWNrRWxlbWVudC5zdGFja1BhdGguc3BsaXQoUEFUSF9TRVApO1xuXG4gICAgY29uc3QgZ2VuZXJhdGVkSWQgPSB0aGlzLm5hbWluZ1NjaGVtZS5hbGxvY2F0ZUFkZHJlc3MocGF0aCk7XG4gICAgY29uc3QgZmluYWxJZCA9IHRoaXMuYXBwbHlSZW5hbWUoZ2VuZXJhdGVkSWQpO1xuICAgIHZhbGlkYXRlTG9naWNhbElkKGZpbmFsSWQpO1xuICAgIHJldHVybiBmaW5hbElkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRocm93IGFuIGVycm9yIGlmIG5vdCBhbGwgcmVuYW1lcyBoYXZlIGJlZW4gdXNlZFxuICAgKlxuICAgKiBUaGlzIGlzIHRvIGFzc3VyZSB0aGF0IHVzZXJzIGRpZG4ndCBtYWtlIHR5cG9lcyB3aGVuIHJlZ2lzdGVyaW5nIHJlbmFtZXMuXG4gICAqL1xuICBwdWJsaWMgYXNzZXJ0QWxsUmVuYW1lc0FwcGxpZWQoKSB7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIE9iamVjdC5rZXlzKHRoaXMucmVuYW1lcykuZm9yRWFjaChrZXlzLmFkZC5iaW5kKGtleXMpKTtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMucmV2ZXJzZSkubWFwKG5ld0lkID0+IHtcbiAgICAgIGtleXMuZGVsZXRlKHRoaXMucmV2ZXJzZVtuZXdJZF0pO1xuICAgIH0pO1xuXG4gICAgaWYgKGtleXMuc2l6ZSAhPT0gMCkge1xuICAgICAgY29uc3QgdW51c2VkUmVuYW1lcyA9IEFycmF5LmZyb20oa2V5cy52YWx1ZXMoKSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmb2xsb3dpbmcgTG9naWNhbCBJRHMgd2VyZSBhdHRlbXB0ZWQgdG8gYmUgcmVuYW1lZCwgYnV0IG5vdCBmb3VuZDogJHt1bnVzZWRSZW5hbWVzLmpvaW4oJywgJyl9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcmVuYW1lZCB2ZXJzaW9uIG9mIGFuIElELCBpZiBhcHBsaWNhYmxlXG4gICAqL1xuICBwcml2YXRlIGFwcGx5UmVuYW1lKG9sZElkOiBzdHJpbmcpIHtcbiAgICBsZXQgbmV3SWQgPSBvbGRJZDtcbiAgICBpZiAob2xkSWQgaW4gdGhpcy5yZW5hbWVzKSB7XG4gICAgICBuZXdJZCA9IHRoaXMucmVuYW1lc1tvbGRJZF07XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyBuZXdJZCBoYXMgYWxyZWFkeSBiZWVuIHVzZWQsIGl0IG11c3QgaGF2ZSBiZWVuIHdpdGggdGhlIHNhbWUgb2xkSWRcbiAgICBpZiAobmV3SWQgaW4gdGhpcy5yZXZlcnNlICYmIHRoaXMucmV2ZXJzZVtuZXdJZF0gIT09IG9sZElkKSB7XG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFR3byBvYmplY3RzIGhhdmUgYmVlbiBhc3NpZ25lZCB0aGUgc2FtZSBMb2dpY2FsIElEOiAnJHt0aGlzLnJldmVyc2VbbmV3SWRdfScgYW5kICcke29sZElkfScgYXJlIG5vdyBib3RoIG5hbWVkICcke25ld0lkfScuYCk7XG4gICAgfVxuICAgIHRoaXMucmV2ZXJzZVtuZXdJZF0gPSBvbGRJZDtcblxuICAgIHJldHVybiBuZXdJZDtcbiAgfVxufVxuXG5jb25zdCBWQUxJRF9MT0dJQ0FMSURfUkVHRVggPSAvXltBLVphLXpdW0EtWmEtejAtOV17MSwyNTR9JC87XG5cbi8qKlxuICogVmFsaWRhdGUgbG9naWNhbCBJRCBpcyB2YWxpZCBmb3IgQ2xvdWRGb3JtYXRpb25cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVMb2dpY2FsSWQobG9naWNhbElkOiBzdHJpbmcpIHtcbiAgaWYgKCFWQUxJRF9MT0dJQ0FMSURfUkVHRVgudGVzdChsb2dpY2FsSWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBMb2dpY2FsIElEIG11c3QgYWRoZXJlIHRvIHRoZSByZWd1bGFyIGV4cHJlc3Npb246ICR7VkFMSURfTE9HSUNBTElEX1JFR0VYLnRvU3RyaW5nKCl9LCBnb3QgJyR7bG9naWNhbElkfSdgKTtcbiAgfVxufVxuIl19