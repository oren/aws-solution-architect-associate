"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stack_1 = require("./cloudformation/stack");
const AVAILABILITY_ZONES_PROVIDER = 'availability-zones';
const SSM_PARAMETER_PROVIDER = 'ssm';
/**
 * Base class for the model side of context providers
 *
 * Instances of this class communicate with context provider plugins in the 'cdk
 * toolkit' via context variables (input), outputting specialized queries for
 * more context variables (output).
 *
 * ContextProvider needs access to a Construct to hook into the context mechanism.
 */
class ContextProvider {
    constructor(context, provider, props = {}) {
        this.context = context;
        this.provider = provider;
        this.stack = stack_1.Stack.find(context);
        this.props = Object.assign({ account: this.stack.env.account, region: this.stack.env.region }, props);
    }
    get key() {
        const propStrings = propsToArray(this.props);
        return `${this.provider}:${propStrings.join(':')}`;
    }
    /**
     * Read a provider value and verify it is not `null`
     */
    getValue(defaultValue) {
        // if account or region is not defined this is probably a test mode, so we just
        // return the default value
        if (!this.props.account || !this.props.region) {
            this.context.addError(formatMissingScopeError(this.provider, this.props));
            return defaultValue;
        }
        const value = this.context.getContext(this.key);
        if (value != null) {
            return value;
        }
        this.stack.reportMissingContext(this.key, {
            provider: this.provider,
            props: this.props,
        });
        return defaultValue;
    }
    /**
     * Read a provider value, verifying it's a string
     * @param defaultValue The value to return if there is no value defined for this context key
     */
    getStringValue(defaultValue) {
        // if scope is undefined, this is probably a test mode, so we just
        // return the default value
        if (!this.props.account || !this.props.region) {
            this.context.addError(formatMissingScopeError(this.provider, this.props));
            return defaultValue;
        }
        const value = this.context.getContext(this.key);
        if (value != null) {
            if (typeof value !== 'string') {
                throw new TypeError(`Expected context parameter '${this.key}' to be a string, but got '${JSON.stringify(value)}'`);
            }
            return value;
        }
        this.stack.reportMissingContext(this.key, {
            provider: this.provider,
            props: this.props,
        });
        return defaultValue;
    }
    /**
     * Read a provider value, verifying it's a list
     * @param defaultValue The value to return if there is no value defined for this context key
     */
    getStringListValue(defaultValue) {
        // if scope is undefined, this is probably a test mode, so we just
        // return the default value and report an error so this in not accidentally used
        // in the toolkit
        if (!this.props.account || !this.props.region) {
            this.context.addError(formatMissingScopeError(this.provider, this.props));
            return defaultValue;
        }
        const value = this.context.getContext(this.key);
        if (value != null) {
            if (!value.map) {
                throw new Error(`Context value '${this.key}' is supposed to be a list, got '${JSON.stringify(value)}'`);
            }
            return value;
        }
        this.stack.reportMissingContext(this.key, {
            provider: this.provider,
            props: this.props,
        });
        return defaultValue;
    }
}
exports.ContextProvider = ContextProvider;
/**
 * Quote colons in all strings so that we can undo the quoting at a later point
 *
 * We'll use $ as a quoting character, for no particularly good reason other
 * than that \ is going to lead to quoting hell when the keys are stored in JSON.
 */
function colonQuote(xs) {
    return xs.replace('$', '$$').replace(':', '$:');
}
/**
 * Context provider that will return the availability zones for the current account and region
 */
class AvailabilityZoneProvider {
    constructor(context) {
        this.provider = new ContextProvider(context, AVAILABILITY_ZONES_PROVIDER);
    }
    /**
     * Return the list of AZs for the current account and region
     */
    get availabilityZones() {
        return this.provider.getStringListValue(['dummy1a', 'dummy1b', 'dummy1c']);
    }
}
exports.AvailabilityZoneProvider = AvailabilityZoneProvider;
/**
 * Context provider that will read values from the SSM parameter store in the indicated account and region
 */
class SSMParameterProvider {
    constructor(context, props) {
        this.provider = new ContextProvider(context, SSM_PARAMETER_PROVIDER, props);
    }
    /**
     * Return the SSM parameter string with the indicated key
     */
    parameterValue(defaultValue = 'dummy') {
        return this.provider.getStringValue(defaultValue);
    }
}
exports.SSMParameterProvider = SSMParameterProvider;
function formatMissingScopeError(provider, props) {
    let s = `Cannot determine scope for context provider ${provider}`;
    const propsString = Object.keys(props).map(key => (`${key}=${props[key]}`));
    s += ` with props: ${propsString}.`;
    s += '\n';
    s += 'This usually happens when AWS credentials are not available and the default account/region cannot be determined.';
    return s;
}
function propsToArray(props) {
    const propArray = [];
    const keys = Object.keys(props);
    keys.sort();
    for (const key of keys) {
        switch (typeof props[key]) {
            case 'object': {
                const childObjStrs = propsToArray(props[key]);
                const qualifiedChildStr = childObjStrs.map(child => (`${key}.${child}`)).join(':');
                propArray.push(qualifiedChildStr);
                break;
            }
            case 'string': {
                propArray.push(`${key}=${colonQuote(props[key])}`);
                break;
            }
            default: {
                propArray.push(`${key}=${JSON.stringify(props[key])}`);
                break;
            }
        }
    }
    return propArray;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGV4dC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvbnRleHQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxrREFBK0M7QUFHL0MsTUFBTSwyQkFBMkIsR0FBRyxvQkFBb0IsQ0FBQztBQUN6RCxNQUFNLHNCQUFzQixHQUFHLEtBQUssQ0FBQztBQUdyQzs7Ozs7Ozs7R0FRRztBQUNILE1BQWEsZUFBZTtJQUsxQixZQUNtQixPQUFrQixFQUNsQixRQUFnQixFQUNqQyxRQUE4QixFQUFFO1FBRmYsWUFBTyxHQUFQLE9BQU8sQ0FBVztRQUNsQixhQUFRLEdBQVIsUUFBUSxDQUFRO1FBRWpDLElBQUksQ0FBQyxLQUFLLEdBQUcsYUFBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNqQyxJQUFJLENBQUMsS0FBSyxtQkFDUixPQUFPLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUMvQixNQUFNLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxJQUMxQixLQUFLLENBQ1QsQ0FBQztJQUNKLENBQUM7SUFFRCxJQUFXLEdBQUc7UUFDWixNQUFNLFdBQVcsR0FBYSxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3ZELE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztJQUNyRCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxRQUFRLENBQUMsWUFBaUI7UUFDL0IsK0VBQStFO1FBQy9FLDJCQUEyQjtRQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRTtZQUM3QyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxL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RCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3RhY2sgfSBmcm9tICcuL2Nsb3VkZm9ybWF0aW9uL3N0YWNrJztcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJy4vY29yZS9jb25zdHJ1Y3QnO1xuXG5jb25zdCBBVkFJTEFCSUxJVFlfWk9ORVNfUFJPVklERVIgPSAnYXZhaWxhYmlsaXR5LXpvbmVzJztcbmNvbnN0IFNTTV9QQVJBTUVURVJfUFJPVklERVIgPSAnc3NtJztcblxudHlwZSBDb250ZXh0UHJvdmlkZXJQcm9wcyA9IHtba2V5OiBzdHJpbmddOiBhbnl9O1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciB0aGUgbW9kZWwgc2lkZSBvZiBjb250ZXh0IHByb3ZpZGVyc1xuICpcbiAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGNvbW11bmljYXRlIHdpdGggY29udGV4dCBwcm92aWRlciBwbHVnaW5zIGluIHRoZSAnY2RrXG4gKiB0b29sa2l0JyB2aWEgY29udGV4dCB2YXJpYWJsZXMgKGlucHV0KSwgb3V0cHV0dGluZyBzcGVjaWFsaXplZCBxdWVyaWVzIGZvclxuICogbW9yZSBjb250ZXh0IHZhcmlhYmxlcyAob3V0cHV0KS5cbiAqXG4gKiBDb250ZXh0UHJvdmlkZXIgbmVlZHMgYWNjZXNzIHRvIGEgQ29uc3RydWN0IHRvIGhvb2sgaW50byB0aGUgY29udGV4dCBtZWNoYW5pc20uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250ZXh0UHJvdmlkZXIge1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgc3RhY2s6IFN0YWNrO1xuICBwcml2YXRlIHJlYWRvbmx5IHByb3BzOiBDb250ZXh0UHJvdmlkZXJQcm9wcztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbnRleHQ6IENvbnN0cnVjdCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHByb3ZpZGVyOiBzdHJpbmcsXG4gICAgcHJvcHM6IENvbnRleHRQcm92aWRlclByb3BzID0ge30pIHtcbiAgICB0aGlzLnN0YWNrID0gU3RhY2suZmluZChjb250ZXh0KTtcbiAgICB0aGlzLnByb3BzID0ge1xuICAgICAgYWNjb3VudDogdGhpcy5zdGFjay5lbnYuYWNjb3VudCxcbiAgICAgIHJlZ2lvbjogdGhpcy5zdGFjay5lbnYucmVnaW9uLFxuICAgICAgLi4ucHJvcHMsXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQga2V5KCk6IHN0cmluZyB7XG4gICAgY29uc3QgcHJvcFN0cmluZ3M6IHN0cmluZ1tdID0gcHJvcHNUb0FycmF5KHRoaXMucHJvcHMpO1xuICAgIHJldHVybiBgJHt0aGlzLnByb3ZpZGVyfToke3Byb3BTdHJpbmdzLmpvaW4oJzonKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSBwcm92aWRlciB2YWx1ZSBhbmQgdmVyaWZ5IGl0IGlzIG5vdCBgbnVsbGBcbiAgICovXG4gIHB1YmxpYyBnZXRWYWx1ZShkZWZhdWx0VmFsdWU6IGFueSk6IGFueSB7XG4gICAgLy8gaWYgYWNjb3VudCBvciByZWdpb24gaXMgbm90IGRlZmluZWQgdGhpcyBpcyBwcm9iYWJseSBhIHRlc3QgbW9kZSwgc28gd2UganVzdFxuICAgIC8vIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgIGlmICghdGhpcy5wcm9wcy5hY2NvdW50IHx8ICF0aGlzLnByb3BzLnJlZ2lvbikge1xuICAgICAgdGhpcy5jb250ZXh0LmFkZEVycm9yKGZvcm1hdE1pc3NpbmdTY29wZUVycm9yKHRoaXMucHJvdmlkZXIsIHRoaXMucHJvcHMpKTtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmNvbnRleHQuZ2V0Q29udGV4dCh0aGlzLmtleSk7XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMuc3RhY2sucmVwb3J0TWlzc2luZ0NvbnRleHQodGhpcy5rZXksIHtcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgcHJvcHM6IHRoaXMucHJvcHMsXG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIHByb3ZpZGVyIHZhbHVlLCB2ZXJpZnlpbmcgaXQncyBhIHN0cmluZ1xuICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgdGhlcmUgaXMgbm8gdmFsdWUgZGVmaW5lZCBmb3IgdGhpcyBjb250ZXh0IGtleVxuICAgKi9cbiAgcHVibGljIGdldFN0cmluZ1ZhbHVlKCBkZWZhdWx0VmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgLy8gaWYgc2NvcGUgaXMgdW5kZWZpbmVkLCB0aGlzIGlzIHByb2JhYmx5IGEgdGVzdCBtb2RlLCBzbyB3ZSBqdXN0XG4gICAgLy8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgaWYgKCF0aGlzLnByb3BzLmFjY291bnQgfHwgIXRoaXMucHJvcHMucmVnaW9uKSB7XG4gICAgICB0aGlzLmNvbnRleHQuYWRkRXJyb3IoZm9ybWF0TWlzc2luZ1Njb3BlRXJyb3IodGhpcy5wcm92aWRlciwgdGhpcy5wcm9wcykpO1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuY29udGV4dC5nZXRDb250ZXh0KHRoaXMua2V5KTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBjb250ZXh0IHBhcmFtZXRlciAnJHt0aGlzLmtleX0nIHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICcke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0nYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFjay5yZXBvcnRNaXNzaW5nQ29udGV4dCh0aGlzLmtleSwge1xuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgICBwcm9wczogdGhpcy5wcm9wcyxcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSBwcm92aWRlciB2YWx1ZSwgdmVyaWZ5aW5nIGl0J3MgYSBsaXN0XG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBpZiB0aGVyZSBpcyBubyB2YWx1ZSBkZWZpbmVkIGZvciB0aGlzIGNvbnRleHQga2V5XG4gICAqL1xuICBwdWJsaWMgZ2V0U3RyaW5nTGlzdFZhbHVlKFxuICAgIGRlZmF1bHRWYWx1ZTogc3RyaW5nW10pOiBzdHJpbmdbXSB7XG4gICAgICAvLyBpZiBzY29wZSBpcyB1bmRlZmluZWQsIHRoaXMgaXMgcHJvYmFibHkgYSB0ZXN0IG1vZGUsIHNvIHdlIGp1c3RcbiAgICAgIC8vIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZSBhbmQgcmVwb3J0IGFuIGVycm9yIHNvIHRoaXMgaW4gbm90IGFjY2lkZW50YWxseSB1c2VkXG4gICAgICAvLyBpbiB0aGUgdG9vbGtpdFxuICAgICAgaWYgKCF0aGlzLnByb3BzLmFjY291bnQgfHwgIXRoaXMucHJvcHMucmVnaW9uKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5hZGRFcnJvcihmb3JtYXRNaXNzaW5nU2NvcGVFcnJvcih0aGlzLnByb3ZpZGVyLCB0aGlzLnByb3BzKSk7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jb250ZXh0LmdldENvbnRleHQodGhpcy5rZXkpO1xuXG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIXZhbHVlLm1hcCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udGV4dCB2YWx1ZSAnJHt0aGlzLmtleX0nIGlzIHN1cHBvc2VkIHRvIGJlIGEgbGlzdCwgZ290ICcke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrLnJlcG9ydE1pc3NpbmdDb250ZXh0KHRoaXMua2V5LCB7XG4gICAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgICBwcm9wczogdGhpcy5wcm9wcyxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBRdW90ZSBjb2xvbnMgaW4gYWxsIHN0cmluZ3Mgc28gdGhhdCB3ZSBjYW4gdW5kbyB0aGUgcXVvdGluZyBhdCBhIGxhdGVyIHBvaW50XG4gKlxuICogV2UnbGwgdXNlICQgYXMgYSBxdW90aW5nIGNoYXJhY3RlciwgZm9yIG5vIHBhcnRpY3VsYXJseSBnb29kIHJlYXNvbiBvdGhlclxuICogdGhhbiB0aGF0IFxcIGlzIGdvaW5nIHRvIGxlYWQgdG8gcXVvdGluZyBoZWxsIHdoZW4gdGhlIGtleXMgYXJlIHN0b3JlZCBpbiBKU09OLlxuICovXG5mdW5jdGlvbiBjb2xvblF1b3RlKHhzOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4geHMucmVwbGFjZSgnJCcsICckJCcpLnJlcGxhY2UoJzonLCAnJDonKTtcbn1cblxuLyoqXG4gKiBDb250ZXh0IHByb3ZpZGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIGF2YWlsYWJpbGl0eSB6b25lcyBmb3IgdGhlIGN1cnJlbnQgYWNjb3VudCBhbmQgcmVnaW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBBdmFpbGFiaWxpdHlab25lUHJvdmlkZXIge1xuICBwcml2YXRlIHByb3ZpZGVyOiBDb250ZXh0UHJvdmlkZXI7XG5cbiAgY29uc3RydWN0b3IoY29udGV4dDogQ29uc3RydWN0KSB7XG4gICAgdGhpcy5wcm92aWRlciA9IG5ldyBDb250ZXh0UHJvdmlkZXIoY29udGV4dCwgQVZBSUxBQklMSVRZX1pPTkVTX1BST1ZJREVSKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxpc3Qgb2YgQVpzIGZvciB0aGUgY3VycmVudCBhY2NvdW50IGFuZCByZWdpb25cbiAgICovXG4gIHB1YmxpYyBnZXQgYXZhaWxhYmlsaXR5Wm9uZXMoKTogc3RyaW5nW10ge1xuXG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0U3RyaW5nTGlzdFZhbHVlKFsnZHVtbXkxYScsICdkdW1teTFiJywgJ2R1bW15MWMnXSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTU01QYXJhbWV0ZXJQcm92aWRlclByb3BzIHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgdG8gbG9va3VwXG4gICAqL1xuICBwYXJhbWV0ZXJOYW1lOiBzdHJpbmc7XG59XG4vKipcbiAqIENvbnRleHQgcHJvdmlkZXIgdGhhdCB3aWxsIHJlYWQgdmFsdWVzIGZyb20gdGhlIFNTTSBwYXJhbWV0ZXIgc3RvcmUgaW4gdGhlIGluZGljYXRlZCBhY2NvdW50IGFuZCByZWdpb25cbiAqL1xuZXhwb3J0IGNsYXNzIFNTTVBhcmFtZXRlclByb3ZpZGVyIHtcbiAgcHJpdmF0ZSBwcm92aWRlcjogQ29udGV4dFByb3ZpZGVyO1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IENvbnN0cnVjdCwgcHJvcHM6IFNTTVBhcmFtZXRlclByb3ZpZGVyUHJvcHMpIHtcbiAgICB0aGlzLnByb3ZpZGVyID0gbmV3IENvbnRleHRQcm92aWRlcihjb250ZXh0LCBTU01fUEFSQU1FVEVSX1BST1ZJREVSLCBwcm9wcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBTU00gcGFyYW1ldGVyIHN0cmluZyB3aXRoIHRoZSBpbmRpY2F0ZWQga2V5XG4gICAqL1xuICBwdWJsaWMgcGFyYW1ldGVyVmFsdWUoZGVmYXVsdFZhbHVlID0gJ2R1bW15Jyk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0U3RyaW5nVmFsdWUoZGVmYXVsdFZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRNaXNzaW5nU2NvcGVFcnJvcihwcm92aWRlcjogc3RyaW5nLCBwcm9wczoge1trZXk6IHN0cmluZ106IHN0cmluZ30pIHtcbiAgbGV0IHMgPSBgQ2Fubm90IGRldGVybWluZSBzY29wZSBmb3IgY29udGV4dCBwcm92aWRlciAke3Byb3ZpZGVyfWA7XG4gIGNvbnN0IHByb3BzU3RyaW5nID0gT2JqZWN0LmtleXMocHJvcHMpLm1hcCgga2V5ID0+IChgJHtrZXl9PSR7cHJvcHNba2V5XX1gKSk7XG4gIHMgKz0gYCB3aXRoIHByb3BzOiAke3Byb3BzU3RyaW5nfS5gO1xuICBzICs9ICdcXG4nO1xuICBzICs9ICdUaGlzIHVzdWFsbHkgaGFwcGVucyB3aGVuIEFXUyBjcmVkZW50aWFscyBhcmUgbm90IGF2YWlsYWJsZSBhbmQgdGhlIGRlZmF1bHQgYWNjb3VudC9yZWdpb24gY2Fubm90IGJlIGRldGVybWluZWQuJztcbiAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIHByb3BzVG9BcnJheShwcm9wczoge1trZXk6IHN0cmluZ106IGFueX0pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHByb3BBcnJheTogc3RyaW5nW10gPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAga2V5cy5zb3J0KCk7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wc1trZXldKSB7XG4gICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgIGNvbnN0IGNoaWxkT2JqU3RycyA9IHByb3BzVG9BcnJheShwcm9wc1trZXldKTtcbiAgICAgICAgY29uc3QgcXVhbGlmaWVkQ2hpbGRTdHIgPSBjaGlsZE9ialN0cnMubWFwKCBjaGlsZCA9PiAoYCR7a2V5fS4ke2NoaWxkfWApKS5qb2luKCc6Jyk7XG4gICAgICAgIHByb3BBcnJheS5wdXNoKHF1YWxpZmllZENoaWxkU3RyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICAgIHByb3BBcnJheS5wdXNoKGAke2tleX09JHtjb2xvblF1b3RlKHByb3BzW2tleV0pfWApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgcHJvcEFycmF5LnB1c2goYCR7a2V5fT0ke0pTT04uc3RyaW5naWZ5KHByb3BzW2tleV0pfWApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BBcnJheTtcbn1cbiJdfQ==