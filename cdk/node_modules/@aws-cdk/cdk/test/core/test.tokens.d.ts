import { Test } from 'nodeunit';
declare const _default: {
    'resolve a plain old object should just return the object'(test: Test): void;
    'if a value is an object with a token value, it will be evaluated'(test: Test): void;
    'tokens are evaluated anywhere in the object tree'(test: Test): void;
    'tokens are evaluated recursively'(test: Test): void;
    'empty arrays or objects are kept'(test: Test): void;
    'if an object has a "resolve" property that is not a function, it is not considered a token'(test: Test): void;
    'if a resolvable object inherits from a class that is also resolvable, the "constructor" function will not get in the way (uses Object.keys instead of "for in")'(test: Test): void;
    'isToken(obj) can be used to determine if an object is a token'(test: Test): void;
    'Token can be used to create tokens that contain a constant value'(test: Test): void;
    'resolving leaves a Date object in working order'(test: Test): void;
    'tokens can be stringified and evaluated to conceptual value'(test: Test): void;
    'Tokens stringification and reversing of CloudFormation Tokens is implemented using Fn::Join'(test: Test): void;
    'Doubly nested strings evaluate correctly in scalar context'(test: Test): void;
    'integer Tokens can be stringified and evaluate to conceptual value'(test: Test): void;
    'intrinsic Tokens can be stringified and evaluate to conceptual value'(test: Test): void;
    'tokens resolve properly in initial position'(test: Test): void;
    'side-by-side Tokens resolve correctly'(test: Test): void;
    'tokens can be used in hash keys but must resolve to a string'(test: Test): void;
    'fails if token in a hash key resolves to a non-string'(test: Test): void;
};
export = _default;
